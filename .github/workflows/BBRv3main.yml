name: Build and Release Kernel BBRv3

on:
  #push:
    #branches:
      #- main
  workflow_dispatch:

env:
  DEBIAN_FRONTEND: noninteractive
  ROOT_DIR_PREFIX: "OP12-A15"
  BRANCH: "android14-6.1"

jobs:
  build-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Important for submodules

      - name: Free Disk Space & Update APT
        run: |
          set -euxo pipefail
          sudo apt-get update -qq && sudo apt-get install -qq curl
          curl -fsSL https://raw.githubusercontent.com/kou/arrow/e49d8ae15583ceff03237571569099a6ad62be32/ci/scripts/util_free_space.sh | bash
      - name: Setup Build Environment
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            python3-pip curl git zip unzip gcc g++ make ninja-build file bc bison flex libssl-dev libelf-dev wget \
            build-essential python3-dev python3-setuptools rsync ccache dwarves
      - name: Cache ccache
        uses: actions/cache@v4
        with:
          path: ~/.ccache
          key: ${{ runner.os }}-ccache-${{ hashFiles('**/CMakeLists.txt') }}
      - name: Setup Python and Repo Tool
        run: |
          set -euxo pipefail
          python3 -m pip install --upgrade pip
          pip3 install gitpython xmltodict
          mkdir -p "$HOME/bin"
          wget -O "$HOME/bin/repo" https://storage.googleapis.com/git-repo-downloads/repo
          chmod a+x "$HOME/bin/repo"
          echo "$HOME/bin" >> $GITHUB_PATH
          git config --global user.name "GitHub Actions Bot"
          git config --global user.email "actions@github.com"
      - name: Configure Build Directory
        id: build_dir
        run: |
          set -euxo pipefail
          ROOT_DIR="${ROOT_DIR_PREFIX}-$(date +'%Y-%m-%d-%I-%M-%p')-release"
          echo "ROOT_DIR=${ROOT_DIR}" >> $GITHUB_ENV
          BUILD_DIR="builds/${ROOT_DIR}"
          echo "BUILD_DIR=${BUILD_DIR}" >> $GITHUB_ENV
          mkdir -p "${BUILD_DIR}"
          echo "Build directory set to ${BUILD_DIR}"
      - name: Clone Required Repositories
        working-directory: ${{ env.BUILD_DIR }}
        run: |
          set -euxo pipefail
          git clone --recursive https://github.com/TheWildJames/AnyKernel3.git -b gki
          git clone https://gitlab.com/simonpunk/susfs4ksu.git -b gki-android14-6.1
          git clone https://github.com/cabagekiller/kernel_patches.git
      - name: Setup Kernel Source
        working-directory: ${{ env.BUILD_DIR }}
        run: |
          set -euxo pipefail
          KERNEL_DIR="kernel_platform/oneplus12_v"
          echo "KERNEL_DIR=${KERNEL_DIR}" >> $GITHUB_ENV
          mkdir -p "${KERNEL_DIR}"
          cd "${KERNEL_DIR}"
          repo init -u https://github.com/OnePlusOSS/kernel_manifest.git -b oneplus/sm8650 -m oneplus12_v.xml --depth=1
          sync_attempts=3
          for i in $(seq 1 $sync_attempts); do
              repo sync -c -j"$(nproc)" --force-sync --no-clone-bundle --no-tags
              if [ $? -eq 0 ]; then break; fi
              echo "Repo sync failed. Attempt $i of $sync_attempts"
              if [ $i -lt $sync_attempts ]; then sleep 60; fi
          done
          [ $? -ne 0 ] && { echo "Repo sync failed after multiple attempts."; exit 1; }
          rm -rf ./kernel_platform/common/android/abi_gki_protected_exports_*
      - name: Setup KernelSU (Submodule Integration)
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          set -euxo pipefail
          curl -LSs "https://raw.githubusercontent.com/rifsxd/KernelSU-Next/next/kernel/setup.sh" | bash -s next-susfs-dev
          git submodule update --init --recursive
          cd KernelSU-Next/kernel
          KSU_VERSION=$(expr $(/usr/bin/git rev-list --count HEAD) "+" 10200)
          echo "KSUVER=$KSU_VERSION" >> $GITHUB_ENV
          sed -i "s/DKSU_VERSION=11998/DKSU_VERSION=${KSU_VERSION}/" Makefile
      - name: Setup SUSFS
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          set -euxo pipefail
          SUSFS_PATCHES="../../../susfs4ksu/kernel_patches"
          KERNEL_PATCHES="../../../kernel_patches"
          KSU_NEXT="KernelSU-Next"
          mkdir -p ./common/fs ./common/include/linux
          cp "${SUSFS_PATCHES}/fs/"* ./common/fs/
          cp "${SUSFS_PATCHES}/include/linux/"* ./common/include/linux/
          #cp "${SUSFS_PATCHES}/KernelSU/10_enable_susfs_for_ksu.patch" "${KSU_NEXT}/"
          cp "${SUSFS_PATCHES}/50_add_susfs_in_gki-android14-6.1.patch" ./common/
          cp "${KERNEL_PATCHES}/69_hide_stuff.patch" ./common/
          cp "${KERNEL_PATCHES}/next/syscall_hooks.patch" ./common/
          cp "${KERNEL_PATCHES}/bbrv3_full.patch" ./common/
          #cp "${KERNEL_PATCHES}/0001-kernel-patch-susfs-v1.5.5-to-KernelSU-Next-v1.0.5.patch" "${KSU_NEXT}/"
          cd "${KSU_NEXT}"
          #patch -p1 --forward < 0001-kernel-patch-susfs-v1.5.5-to-KernelSU-Next-v1.0.5.patch || echo "Warning: KernelSU SUSFS patch may have been already applied or failed."
          cd ../common
          patch -p1 -F 3 < bbrv3_full.patch || true
          patch -p1 --forward < syscall_hooks.patch || echo "Warning: KernelSU SUSFS patch may have been already applied or failed."
          patch -p1 < 50_add_susfs_in_gki-android14-6.1.patch || echo "Warning: SUSFS patch may have been already applied."
          patch -p1 -F 3 < 69_hide_stuff.patch || echo "Warning: 69_hide_stuff patch may have been already applied."
           
          #sed -i '/obj-$(CONFIG_KSU_SUSFS_SUS_SU) += sus_su.o/d' ./fs/Makefile
          git diff --quiet --exit-code || (git add -A && git commit -m "BUILD Kernel (SUSFS setup)" || true)
          cd ..
          git diff --quiet --exit-code || (git add -A && git commit -m "BUILD Kernel (SUSFS setup)" || true)
          git rm --cached KernelSU-Next || true
      - name: Configure Kernel
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          set -euxo pipefail
           # Add SUSFS configuration settings
          echo "CONFIG_KSU=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_HAS_MAGIC_MOUNT=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_SUS_PATH=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_SUS_MOUNT=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_KSU_DEFAULT_MOUNT=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_AUTO_ADD_SUS_BIND_MOUNT=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_SUS_KSTAT=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_SUS_OVERLAYFS=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_TRY_UMOUNT=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_AUTO_ADD_TRY_UMOUNT_FOR_BIND_MOUNT=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_SPOOF_UNAME=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_ENABLE_LOG=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_HIDE_KSU_SUSFS_SYMBOLS=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_SPOOF_CMDLINE_OR_BOOTCONFIG=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_OPEN_REDIRECT=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_SUSFS_SUS_SU=n" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_KSU_WITH_KPROBES=n" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_COMPAT=y" >> ./common/arch/arm64/configs/gki_defconfig
          # Add additional tmpfs config setting
          echo "CONFIG_TMPFS_XATTR=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_TMPFS_POSIX_ACL=y" >> ./common/arch/arm64/configs/gki_defconfig
          # Add additional tmpfs config setting
          echo "CONFIG_IP_NF_TARGET_TTL=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_IP6_NF_TARGET_HL=y" >> ./common/arch/arm64/configs/gki_defconfig
          echo "CONFIG_IP6_NF_MATCH_HL=y" >> ./common/arch/arm64/configs/gki_defconfig
          # Enable BBR and Set as Default 
          echo "CONFIG_TCP_CONG_ADVANCED=y" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "CONFIG_TCP_CONG_BBR=y" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "CONFIG_DEFAULT_BBR=y" >> ./common/arch/arm64/configs/gki_defconfig 
          echo 'CONFIG_DEFAULT_TCP_CONG="bbr"' >> ./common/arch/arm64/configs/gki_defconfig 

          # Optional: Keep Reno/Cubic as alternatives 
          echo "CONFIG_TCP_CONG_CUBIC=y" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "CONFIG_TCP_CONG_RENO=y" >> ./common/arch/arm64/configs/gki_defconfig 
          # Disable Unnecessary TCP Congestion Algorithms 
          echo "# CONFIG_TCP_CONG_BIC is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_WESTWOOD is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_HTCP is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_HSTCP is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_HYBLA is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_VEGAS is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_NV is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_SCALABLE is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_LP is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_VENO is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_YEAH is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_ILLINOIS is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_DCTCP is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_TCP_CONG_CDG is not set" >> ./common/arch/arm64/configs/gki_defconfig 

          # Disable Other Default Congestion Controls 
          echo "# CONFIG_DEFAULT_BIC is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_DEFAULT_HTCP is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_DEFAULT_WESTWOOD is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_DEFAULT_RENO is not set" >> ./common/arch/arm64/configs/gki_defconfig 

          # Enable FQ-CoDel for Queue Management 
          echo "CONFIG_NET_SCH_FQ_CODEL=y" >> ./common/arch/arm64/configs/gki_defconfig 

          # Disable Other Queuing Disciplines 
          echo "# CONFIG_NET_SCH_NETEM is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_NET_SCH_CBS is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_NET_SCH_DEFAULT is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_NET_SCH_HTB is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_NET_SCH_HFSC is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_NET_SCH_PRIO is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_NET_SCH_RED is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_NET_SCH_SFQ is not set" >> ./common/arch/arm64/configs/gki_defconfig 
          echo "# CONFIG_NET_SCH_TBF is not set" >> ./common/arch/arm64/configs/gki_defconfig
          # Remove defconfig check
          sed -i '2s/check_defconfig//' ./common/build.config.gki
      - name: ♻️ Restore missing Linux kernel headers for BBRv3 integration
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          set -euxo pipefail
          echo "📥 Cloning upstream Linux kernel source..."
          git clone --depth=1 https://github.com/torvalds/linux.git upstream-linux
      
          echo "🧩 Copying missing headers to kernel source..."
          declare -a headers=(
            "include/net/netns/mib.h"
            "include/net/netns/conntrack.h"
            "include/net/netns/ipv4.h"
            "include/net/netns/ipv6.h"
            "include/net/netns/nexthop.h"
          )
      
          for header in "${headers[@]}"; do
            if [[ -f "upstream-linux/$header" ]]; then
              target_dir="common/$(dirname "$header")"
              mkdir -p "$target_dir"
              cp "upstream-linux/$header" "$target_dir"
              echo "✅ Copied: $header → $target_dir"
            else
              echo "⚠️  Missing in upstream: $header (skipped)"
            fi
          done
          # Copy all files recursively from upstream-linux/include/linux to common/include/linux
          echo "📂 Copying all headers from upstream Linux include/linux..."
          cp -r upstream-linux/include/linux/* common/include/linux/
          echo "✅ Copied all headers from upstream Linux include/linux"
          # Copy uapi headers from upstream-linux/include/uapi/linux to common/include/uapi/linux
          echo "📂 Copying all uapi headers from upstream Linux include/uapi/linux..."
          cp -r upstream-linux/include/uapi/linux/* common/include/uapi/linux/
          echo "✅ Copied all uapi headers from upstream Linux include/uapi/linux"
          mkdir -p common/include/net/netns
          cp upstream-linux/include/net/netns/mib.h common/include/net/netns/mib.h
          echo "🎉 Header restoration complete!"
      - name: ♻️ Restore kernel/pgo from Android common kernel
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          set -euxo pipefail
          echo "📥 Cloning Android kernel common tree (android14-6.1)..."
          git clone --depth=1 --branch android14-6.1 https://android.googlesource.com/kernel/common android-kernel
      
          echo "📂 Copying kernel/pgo..."
          if [ -d android-kernel/kernel/pgo ]; then
            mkdir -p common/kernel/pgo
            cp -r android-kernel/kernel/pgo/* common/kernel/pgo/
            echo "✅ kernel/pgo restored successfully."
          else
            echo "⚠️  kernel/pgo not found in android14-6.1 — skipping copy."
          fi
      
          echo "🧹 Cleaning up..."
          rm -rf android-kernel
      - name: ⚙️ Integrate BBRv3 into kernel source
        shell: bash
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
            set -euxo pipefail
        
            echo "📥 Cloning Google BBRv3 source..."
            git clone --depth=1 --branch v3 https://github.com/google/bbr bbrv3
        
            echo "📁 Preparing BBRv3 file list..."
            declare -A file_map=(
              [bbrv3/bbr/net/ipv4/tcp_bbr.c]=common/net/ipv4/tcp_bbr.c
              [bbrv3/bbr/include/uapi/linux/tcp_bbr.h]=common/include/uapi/linux/tcp_bbr.h
              [bbrv3/bbr/include/linux/tcp_bbr2_plus.h]=common/include/linux/tcp_bbr2_plus.h
              [bbrv3/bbr/include/net/tcp_bbr2_plus_impl.h]=common/include/net/tcp_bbr2_plus_impl.h
              [bbrv3/bbr/include/net/tcp_bbr2_plus_common.h]=common/include/net/tcp_bbr2_plus_common.h
              [bbrv3/bbr/include/net/tcp_bbr2_plus_bw_probe.h]=common/include/net/tcp_bbr2_plus_bw_probe.h
              [bbrv3/bbr/include/net/tcp_bbr2_plus_minrtt.h]=common/include/net/tcp_bbr2_plus_minrtt.h
              [bbrv3/bbr/include/net/tcp_bbr2_plus_model.h]=common/include/net/tcp_bbr2_plus_model.h
              [bbrv3/bbr/include/net/tcp_bbr2_plus_probe_rtt.h]=common/include/net/tcp_bbr2_plus_probe_rtt.h
            )
        
            echo "🔁 Copying BBRv3 files into kernel source..."
            for src in "${!file_map[@]}"; do
              dst=${file_map[$src]}
              if [[ -f "$src" ]]; then
                mkdir -p "$(dirname "$dst")"
                cp "$src" "$dst"
                echo "✅ Copied: $src → $dst"
              else
                echo "⚠️  Skipped missing: $src"
              fi
            done
        
            echo "🛠️ Patching Makefile..."
            MAKEFILE_PATH="common/net/ipv4/Makefile"
            if ! grep -q "tcp_bbr.o" "$MAKEFILE_PATH"; then
              echo "obj-\$(CONFIG_TCP_CONG_BBR3) += tcp_bbr.o" >> "$MAKEFILE_PATH"
              echo "✅ Added tcp_bbr.o to $MAKEFILE_PATH"
            else
              echo "ℹ️ tcp_bbr.o already in Makefile."
            fi
        
            echo "🧩 Updating defconfig..."
            DEFCONFIG_PATH="common/arch/arm64/configs/gki_defconfig"
            if ! grep -q "CONFIG_TCP_CONG_BBR3" "$DEFCONFIG_PATH"; then
              echo "CONFIG_TCP_CONG_BBR3=y" >> "$DEFCONFIG_PATH"
              echo "✅ Enabled CONFIG_TCP_CONG_BBR3"
            else
              echo "ℹ️ CONFIG_TCP_CONG_BBR3 already enabled."
            fi
        
            echo "🎉 BBRv3 integration completed!"

      - name: Clone upstream Linux kernel (for missing headers)
        run: |
          git clone --depth=1 https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git upstream-linux
      - name: Restore missing netns/mib.h from upstream
        run: |
          echo "[*] Restoring netns/mib.h if needed..."
          TARGET_HEADER_PATH="common/include/net/netns/mib.h"
          if [ ! -f "$TARGET_HEADER_PATH" ]; then
            echo "[-] mib.h not found. Copying from upstream..."
            mkdir -p "$(dirname "$TARGET_HEADER_PATH")"
            cp upstream-linux/include/net/netns/mib.h "$TARGET_HEADER_PATH"
          else
            echo "[+] mib.h already exists at $TARGET_HEADER_PATH"
          fi
  
          # Also ensure Bazel can see it in the execroot
          EXECROOT=$(find out/bazel/output_user_root -type d -name 'execroot' | head -n 1)
          if [ -n "$EXECROOT" ]; then
            echo "[*] Copying mib.h to Bazel execroot..."
            mkdir -p "$EXECROOT/__main__/common/include/net/netns"
            cp "$TARGET_HEADER_PATH" "$EXECROOT/__main__/common/include/net/netns/mib.h"
          fi
      - name: 🩹 Patch Makefile to avoid creating bad symlink
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform/common
        run: |
          echo "🔧 Replacing 'ln -fsn' with conditional safe version"
          sed -i 's|ln -fsn.*source|test "$(realpath source 2>/dev/null)" != "$(realpath .)" \&\& ln -fsn $(srctree) source|' Makefile
          echo "✅ Makefile patch complete"
      - name: 🩹 Patch compiler_types.h to avoid CONFIG_FUNCTION_ALIGNMENT errors
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          echo "🔧 Patching compiler_types.h"
          sed -i 's/#if CONFIG_FUNCTION_ALIGNMENT > 0/#if defined(CONFIG_FUNCTION_ALIGNMENT) \&\& CONFIG_FUNCTION_ALIGNMENT > 0/' common/include/linux/compiler_types.h
          sed -i 's/(CONFIG_FUNCTION_ALIGNMENT == 0)/(defined(CONFIG_FUNCTION_ALIGNMENT) \&\& CONFIG_FUNCTION_ALIGNMENT == 0)/' common/include/linux/compiler_types.h
          echo "✅ Patch applied"
      - name: 🩹 Patch missing atomic long ops for ARM64
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        shell: bash
        run: |
          PATCH_FILE="common/arch/arm64/include/asm/atomic_ll_sc.h"
          MARKER="_ARM64_PATCHED_ATOMIC_LL_SC_FALLBACKS_H"
      
          if ! grep -q "$MARKER" "$PATCH_FILE"; then
            echo "🔧 Appending atomic long fallback bundle to $PATCH_FILE"
            cat << 'EOF' >> "$PATCH_FILE"
          #include <linux/atomic/atomic-long.h>
          
          #ifndef raw_atomic64_read
          #define raw_atomic64_read(v) atomic64_read(v)
          #endif
          
          #ifndef raw_atomic64_read_acquire
          #define raw_atomic64_read_acquire(v) atomic64_read_acquire(v)
          #endif
          
          #ifndef arch_atomic_long_fetch_andnot_release
          static inline long arch_atomic_long_fetch_andnot_release(long i, atomic_long_t *v)
          {
              long old, new;
              do {
                  old = atomic_long_read(v);
                  new = old & ~i;
              } while (atomic_long_cmpxchg_release(v, old, new) != old);
              return old;
          }
          #endif
          
          #ifndef arch_atomic_long_fetch_xor
          static inline long arch_atomic_long_fetch_xor(long i, atomic_long_t *v)
          {
              long old, new;
              do {
                  old = atomic_long_read(v);
                  new = old ^ i;
              } while (atomic_long_cmpxchg(v, old, new) != old);
              return old;
          }
          #endif
          
          #ifndef arch_atomic_long_fetch_or
          static inline long arch_atomic_long_fetch_or(long i, atomic_long_t *v)
          {
              long old, new;
              do {
                  old = atomic_long_read(v);
                  new = old | i;
              } while (atomic_long_cmpxchg(v, old, new) != old);
              return old;
          }
          #endif
          
          #ifndef arch_atomic_long_fetch_and
          static inline long arch_atomic_long_fetch_and(long i, atomic_long_t *v)
          {
              long old, new;
              do {
                  old = atomic_long_read(v);
                  new = old & i;
              } while (atomic_long_cmpxchg(v, old, new) != old);
              return old;
          }
          #endif
          EOF
              else
                echo "✅ Atomic fallback bundle already present"
              fi
      - name: 🧩 Inject raw_atomic64 & asm_volatile_goto fallbacks
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: bash $GITHUB_WORKSPACE/scripts/inject_kernel_header_fallbacks.sh

      - name: ⚙️ Generate and patch kernel config
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          set -euxo pipefail
          echo "📦 Running defconfig"
          make -C common O=out ARCH=arm64 ${DEFCONFIG:-defconfig}
      
          echo "📁 Ensuring .config exists"
          CONFIG_PATH=common/out/.config
          mkdir -p common/out
          touch "$CONFIG_PATH"
      
          echo "🛠 Disabling CONFIG_PGO_CLANG"
          sed -i '/^CONFIG_PGO_CLANG/d' "$CONFIG_PATH" || true
          echo "CONFIG_PGO_CLANG=n" >> "$CONFIG_PATH"
      
          echo "🔧 Ensuring CONFIG_FUNCTION_ALIGNMENT=0"
          if ! grep -q '^CONFIG_FUNCTION_ALIGNMENT=' "$CONFIG_PATH"; then
            echo 'CONFIG_FUNCTION_ALIGNMENT=0' >> "$CONFIG_PATH"
          fi
      
          echo "📦 Finalizing config"
          make -C common O=out ARCH=arm64 olddefconfig
      
          echo "💾 Backing up locked config"
          cp "$CONFIG_PATH" "$CONFIG_PATH.locked"
      - name: 🩹 Patch compiler_types.h for missing config guard
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          echo "🔧 Patching compiler_types.h"
          sed -i 's/#if CONFIG_FUNCTION_ALIGNMENT > 0/#if defined(CONFIG_FUNCTION_ALIGNMENT) \&\& CONFIG_FUNCTION_ALIGNMENT > 0/' common/include/linux/compiler_types.h
          sed -i 's/(CONFIG_FUNCTION_ALIGNMENT == 0)/(defined(CONFIG_FUNCTION_ALIGNMENT) \&\& CONFIG_FUNCTION_ALIGNMENT == 0)/' common/include/linux/compiler_types.h
          echo "✅ Patch applied"
      - name: 🔒 Restore and lock .config before Bazel
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        env:
          KCONFIG_CONFIG: common/out/.config
        run: |
          echo "🔁 Restoring locked config"
          cp common/out/.config.locked common/out/.config
          #chmod 444 common/out/.config
      - name: 🧩 Patch Kleaf to prevent source- symlink
        working-directory: ${{ env.BUILD_DIR }}/kernel_platform/oneplus12_v/kernel_platform
        run: |
          echo "🔧 Disabling out/source- symlink to prevent infinite loop"
          sed -i 's/ctx\.actions\.symlink/# ctx.actions.symlink/' build/kernel/kleaf/impl/kernel_env.bzl
      - name: 🔧 Patch kernel build system (remove symlink & disable kernel_toolchain_info)
        working-directory: ${{ env.BUILD_DIR }}/kernel_platform/oneplus12_v/kernel_platform
        run: |
          echo "🧹 Removing problematic symlink: common/out/source-"
          rm -f common/out/source-
      
          if [ -f WORKSPACE ]; then
            echo "🛠 Disabling kernel_toolchain_info local_repository in WORKSPACE"
            sed -i '/local_repository.*kernel_toolchain_info/,/)/ s/^/# 🔒 disabled: /' WORKSPACE
          else
            echo "⚠️ No WORKSPACE file found to patch."
          fi
      - name: 🩹 Patch kernel_env.bzl to prevent source- symlink
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          echo "🔧 Disabling creation of 'out/source-' symlink in kernel_env.bzl"
          sed -i '/ctx\.actions\.symlink/ s/^/# 🚫 disabled: /' build/kernel/kleaf/impl/kernel_env.bzl
          echo "✅ Patched kernel_env.bzl"
      - name: 🧹 Remove & patch bad symlinks before Bazel
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          echo "🧹 Removing symlinks that cause Bazel recursion"
          rm -f common/out/source common/out/source-
      
          echo "🛠 Creating dummy safe symlink for source-"
          ln -s /dev/null common/out/source-
      
          echo "✅ source- is now harmless"

      - name: 🩹 Patch compiler_types.h to guard CONFIG_FUNCTION_ALIGNMENT
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          echo "🔧 Patching compiler_types.h for missing CONFIG_FUNCTION_ALIGNMENT"
          sed -i 's/#if CONFIG_FUNCTION_ALIGNMENT > 0/#if defined(CONFIG_FUNCTION_ALIGNMENT) \&\& CONFIG_FUNCTION_ALIGNMENT > 0/' common/include/linux/compiler_types.h
          sed -i 's/(CONFIG_FUNCTION_ALIGNMENT == 0)/(defined(CONFIG_FUNCTION_ALIGNMENT) \&\& CONFIG_FUNCTION_ALIGNMENT == 0)/' common/include/linux/compiler_types.h
          echo "✅ Patch applied"
      - name: 🔒 Restore and lock .config before Bazel
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        env:
          KCONFIG_CONFIG: common/out/.config
        run: |
          echo "📁 Ensuring config file exists"
          mkdir -p common/out
          touch common/out/.config
      
          echo "🔧 Injecting CONFIG_FUNCTION_ALIGNMENT=0"
          grep -q '^CONFIG_FUNCTION_ALIGNMENT=' common/out/.config || echo 'CONFIG_FUNCTION_ALIGNMENT=0' >> common/out/.config
      
          echo "🔐 Locking config"
          chmod 444 common/out/.config
      # ✅ After source sync, KernelSU/SUSFS/BBRv3 patching, etc.
      - name: 🩹 Patch fallback for asm_volatile_goto
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        shell: bash
        run: |
          COMPILER_TYPES_HEADER="common/include/linux/compiler_types.h"
      
          if ! grep -q 'asm_volatile_goto' "$COMPILER_TYPES_HEADER"; then
            echo "🔧 Adding fallback macro for asm_volatile_goto"
            cat << 'EOF' >> "$COMPILER_TYPES_HEADER"
      
          #ifndef asm_volatile_goto
          #define asm_volatile_goto(...) asm volatile(__VA_ARGS__)
          #endif
          EOF
              else
                echo "✅ asm_volatile_goto already defined"
              fi

      - name: 🩹 Patch asm_volatile_goto fallback for jump label
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          JUMP_LABEL_HEADER="common/arch/arm64/include/asm/jump_label.h"
          if ! grep -q 'asm_volatile_goto' "$JUMP_LABEL_HEADER"; then
            echo "🔧 Adding fallback for asm_volatile_goto"
            cat << 'EOF' >> "$JUMP_LABEL_HEADER"
      
          #ifndef asm_volatile_goto
          #define asm_volatile_goto(...) asm volatile(__VA_ARGS__)
          #endif
          EOF
              else
                echo "✅ asm_volatile_goto already defined"
              fi

      - name: 🩹 Include atomic-long.h for atomic_long_t support
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          ATOMIC_HEADER="common/arch/arm64/include/asm/atomic_ll_sc.h"
          if ! grep -q 'atomic-long.h' "$ATOMIC_HEADER"; then
            echo "🔧 Inserting include for atomic-long.h"
            sed -i '1i#include <linux/atomic/atomic-long.h>' "$ATOMIC_HEADER"
          else
            echo "✅ atomic-long.h already included"
          fi
      - name: 🩹 Backport missing arch_atomic_long_fetch_andnot_release for ARM64
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        shell: bash
        run: |
          ATOMIC_HEADER="common/arch/arm64/include/asm/atomic_ll_sc.h"
      
          if ! grep -q 'arch_atomic_long_fetch_andnot_release' "$ATOMIC_HEADER"; then
            echo "🔧 Patching $ATOMIC_HEADER with arch_atomic_long_fetch_andnot_release"
            cat << 'EOF' >> "$ATOMIC_HEADER"
                #ifndef arch_atomic_long_fetch_andnot_release
          static inline long arch_atomic_long_fetch_andnot_release(long i, atomic_long_t *v)
          {
            long old, new;
            do {
              old = atomic_long_read(v);
              new = old & ~i;
            } while (atomic_long_cmpxchg_release(v, old, new) != old);
            return old;
          }
          #endif
          EOF
          else
            echo "✅ arch_atomic_long_fetch_andnot_release already defined"
          fi
      - name: 🩹 Backport arch_atomic_long_fetch_xor for ARM64
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        shell: bash
        run: |
          ATOMIC_HEADER="common/arch/arm64/include/asm/atomic_ll_sc.h"
      
          if ! grep -q 'arch_atomic_long_fetch_xor' "$ATOMIC_HEADER"; then
            echo "🔧 Patching $ATOMIC_HEADER with arch_atomic_long_fetch_xor"
            cat << 'EOF' >> "$ATOMIC_HEADER"
      
          #ifndef arch_atomic_long_fetch_xor
          static inline long arch_atomic_long_fetch_xor(long i, atomic_long_t *v)
          {
              long old, new;
              do {
                  old = atomic_long_read(v);
                  new = old ^ i;
              } while (atomic_long_cmpxchg(v, old, new) != old);
              return old;
          }
          #endif
          EOF
              else
                echo "✅ arch_atomic_long_fetch_xor already defined"
              fi

      - name: Fix Atomic Function Names
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          set -euxo pipefail
          find common/arch/arm64/include/asm/ -name "*.h" -print0 | xargs -0 sed -i 's/arch_atomic_long_or/raw_atomic_long_or/g'
          find common/arch/arm64/include/asm/ -name "*.h" -print0 | xargs -0 sed -i 's/arch_atomic_long_andnot/raw_atomic_long_andnot/g'
          find common/arch/arm64/include/asm/ -name "*.h" -print0 | xargs -0 sed -i 's/arch_atomic_long_xor/raw_atomic_long_xor/g'
          find common/arch/arm64/include/asm/ -name "*.h" -print0 | xargs -0 sed -i 's/arch_atomic_long_fetch_or/raw_atomic_long_fetch_or/g'
          find common/arch/arm64/include/asm/ -name "*.h" -print0 | xargs -0 sed -i 's/arch_atomic_long_fetch_andnot/raw_atomic_long_fetch_andnot/g'
          find common/arch/arm64/include/asm/ -name "*.h" -print0 | xargs -0 sed -i 's/arch_atomic_long_fetch_xor/raw_atomic_long_fetch_xor/g'
          find common/arch/arm64/include/asm/ -name "*.h" -print0 | xargs -0 sed -i 's/asm_volatile_goto(/asm_volatile_goto(/g'
          find common/arch/arm64/include/asm/ -name "*.h" -print0 | xargs -0 sed -i 's/:  :  "i"(&((char \\*)key)\\[branch\\]) :  : l_yes);/:  :  "i"(&((char \\*)key)\\[branch\\]) :  : l_yes);)/g'
          sed -i 's/static atomic_long_read/atomic_long_read/g' common/include/linux/atomic/atomic-instrumented.h
          sed -i 's/static atomic_long_cmpxchg_release/atomic_long_cmpxchg_release/g' common/include/linux/atomic/atomic-instrumented.h
      - name: 🔧 Include raw64 compat header in atomic_ll_sc.h
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          HEADER_FILE="common/arch/arm64/include/asm/atomic_ll_sc.h"
          grep -q 'atomic-raw64-compat.h' "$HEADER_FILE" || \
            sed -i '/atomic-long.h/a #include <linux/atomic/atomic-raw64-compat.h>' "$HEADER_FILE"

      - name: 📥 Copy fallback header into kernel tree
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          cp $GITHUB_WORKSPACE/patches/atomic-raw64-compat.h common/include/linux/atomic/
      - name: 🪛 Inject fallback headers for BBRv3 support
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          set -euxo pipefail
      
          echo "📥 Copying compiler_types fallback..."
          cp "$GITHUB_WORKSPACE/fallback_headers/compiler_types_fallback.h" "common/include/linux/compiler_types.h"
      
          echo "📥 Copying atomic_ll_sc fallback..."
          cp "$GITHUB_WORKSPACE/fallback_headers/atomic_ll_sc_fallback.h" "common/arch/arm64/include/asm/atomic_ll_sc.h"
      - name: 🩹 Patch kernel headers for user-space compilation
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Add __user macro definition if not present
          USER_DEF_FILE="common/include/linux/compiler_types.h"
          if ! grep -q '#define __user' "$USER_DEF_FILE"; then
            echo -e "\n#ifndef __user\n#define __user\n#endif" >> "$USER_DEF_FILE"
            echo "✅ Added __user macro definition"
          else
            echo "ℹ️ __user macro already defined"
          fi
      
          # Fix capability.h typedefs
          CAPABILITY_FILE="common/include/uapi/linux/capability.h"
          sed -i 's/} __user \*cap_user_header_t;/};\ntypedef struct __user_cap_header_struct *cap_user_header_t;/' "$CAPABILITY_FILE"
          sed -i 's/typedef struct __user_cap_data_struct __user \*cap_user_data_t;/typedef struct __user_cap_data_struct *cap_user_data_t;/' "$CAPABILITY_FILE"
          echo "✅ Fixed capability.h typedef syntax"
      - name: 🛠️ Comprehensive kernel headers patch
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Create compiler attributes patch
          COMPILER_FILE="common/include/linux/compiler_attributes.h"
          if [ ! -f "$COMPILER_FILE" ]; then
            COMPILER_FILE="common/include/linux/compiler.h"
          fi
      
          # Add all necessary definitions
          cat << 'EOF' >> "$COMPILER_FILE"
      
          /* User-space compilation workarounds */
          #ifndef __user
          #define __user
          #endif
          #ifndef __kernel
          #define __kernel
          #endif
          #ifndef __force
          #define __force
          #endif
          #ifndef __must_check
          #define __must_check
          #endif
          #ifndef __no_sanitize_or_inline
          #define __no_sanitize_or_inline inline
          #endif
          #ifndef __no_kasan_or_inline
          #define __no_kasan_or_inline inline
          #endif
          #ifndef __realloc_size
          #define __realloc_size(x, ...)
          #endif
          #ifndef __unqual_scalar_typeof
          #define __unqual_scalar_typeof(x) typeof(x)
          #endif
          #ifndef __counted_by
          #define __counted_by(x)
          #endif
          EOF
      
          # Fix specific files
          RWONCE_FILE="common/include/asm-generic/rwonce.h"
          [ -f "$RWONCE_FILE" ] && sed -i 's/__no_[a-z_]*_inline/inline/g' "$RWONCE_FILE"
      
          ERR_FILE="common/include/linux/err.h"
          [ -f "$ERR_FILE" ] && sed -i 's/__force //g' "$ERR_FILE"
      
          echo "✅ Applied comprehensive kernel headers patch"
      - name: 🛠️ Patch kernel headers for user-space compilation
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Create a comprehensive compiler attributes patch
          COMPILER_FILE="common/include/linux/compiler_attributes.h"
          if [ ! -f "$COMPILER_FILE" ]; then
            COMPILER_FILE="common/include/linux/compiler.h"
          fi
      
          # Add all necessary definitions
          cat << 'EOF' >> "$COMPILER_FILE"
      
          /* User-space compilation workarounds */
          #ifndef __user
          #define __user
          #endif
          #ifndef __kernel
          #define __kernel
          #endif
          #ifndef __force
          #define __force
          #endif
          #ifndef __must_check
          #define __must_check
          #endif
          #ifndef __cold
          #define __cold
          #endif
          #ifndef __noreturn
          #define __noreturn
          #endif
          #ifndef __section
          #define __section(x)
          #endif
          #ifndef __latent_entropy
          #define __latent_entropy
          #endif
          #ifndef __noinitretpoline
          #define __noinitretpoline
          #endif
          #ifndef __no_sanitize_or_inline
          #define __no_sanitize_or_inline inline
          #endif
          #ifndef __no_kasan_or_inline
          #define __no_kasan_or_inline inline
          #endif
          #ifndef __realloc_size
          #define __realloc_size(x, ...)
          #endif
          #ifndef __unqual_scalar_typeof
          #define __unqual_scalar_typeof(x) typeof(x)
          #endif
          #ifndef __counted_by
          #define __counted_by(x)
          #endif
          #ifndef __member_size
          #define __member_size(p) 0
          #endif
          #ifndef __fortify_panic
          #define __fortify_panic(reason, avail, size) abort()
          #endif
          #ifndef fortify_panic
          #define fortify_panic(func, write, avail, size, p) abort()
          #endif
          EOF
      
          # Fix capability.h typedef
          CAPABILITY_FILE="common/include/uapi/linux/capability.h"
          sed -i 's/typedef struct __user_cap_header_struct {/struct __user_cap_header_struct {/' "$CAPABILITY_FILE"
          sed -i '/struct __user_cap_header_struct {/a typedef struct __user_cap_header_struct *cap_user_header_t;' "$CAPABILITY_FILE"
          sed -i 's/typedef struct __user_cap_data_struct __user \*cap_user_data_t;/typedef struct __user_cap_data_struct *cap_user_data_t;/' "$CAPABILITY_FILE"
      
          # Fix rwonce.h
          RWONCE_FILE="common/include/asm-generic/rwonce.h"
          [ -f "$RWONCE_FILE" ] && sed -i 's/__no_[a-z_]*_inline/inline/g' "$RWONCE_FILE"
      
          # Fix printk.h
          PRINTK_FILE="common/include/linux/printk.h"
          [ -f "$PRINTK_FILE" ] && sed -i 's/__cold//g' "$PRINTK_FILE"
      
          # Fix init.h
          INIT_FILE="common/include/linux/init.h"
          [ -f "$INIT_FILE" ] && sed -i 's/__cold//g' "$INIT_FILE"
          [ -f "$INIT_FILE" ] && sed -i 's/__latent_entropy//g' "$INIT_FILE"
          [ -f "$INIT_FILE" ] && sed -i 's/__noinitretpoline//g' "$INIT_FILE"
      
          # Fix fortify-string.h
          FORTIFY_FILE="common/include/linux/fortify-string.h"
          [ -f "$FORTIFY_FILE" ] && sed -i 's/__cold//g' "$FORTIFY_FILE"
          [ -f "$FORTIFY_FILE" ] && sed -i 's/__noreturn//g' "$FORTIFY_FILE"
      
          echo "✅ Applied comprehensive kernel headers patch"
      - name: 🛠️ Comprehensive capability.h patch
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          CAPABILITY_FILE="common/include/uapi/linux/capability.h"
          
          # Backup original file
          cp "$CAPABILITY_FILE" "${CAPABILITY_FILE}.orig"
          
          # Apply comprehensive fix
          cat << 'EOF' > "$CAPABILITY_FILE"
          #ifndef _LINUX_CAPABILITY_H
          #define _LINUX_CAPABILITY_H
          
          #include <linux/types.h>
          
          struct __user_cap_header_struct {
              __u32 version;
              int pid;
          };
          typedef struct __user_cap_header_struct *cap_user_header_t;
          
          struct __user_cap_data_struct {
              __u32 effective;
              __u32 permitted;
              __u32 inheritable;
          };
          typedef struct __user_cap_data_struct *cap_user_data_t;
          
          #define _LINUX_CAPABILITY_VERSION_1  0x19980330
          #define _LINUX_CAPABILITY_U32S_1     1
          
          #define _LINUX_CAPABILITY_VERSION_2  0x20071026
          #define _LINUX_CAPABILITY_U32S_2     2
          
          #define _LINUX_CAPABILITY_VERSION_3  0x20080522
          #define _LINUX_CAPABILITY_U32S_3     2
          
          #endif /* _LINUX_CAPABILITY_H */
          EOF
          
          echo "✅ Completely rebuilt capability.h with fixed typedefs"
      - name: 🛠️ Patch kernel headers for user-space compilation
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Create a comprehensive compiler attributes patch
          COMPILER_FILE="common/include/linux/compiler_attributes.h"
          if [ ! -f "$COMPILER_FILE" ]; then
            COMPILER_FILE="common/include/linux/compiler.h"
          fi
      
          # Add all necessary definitions
          cat << 'EOF' >> "$COMPILER_FILE"
      
          /* User-space compilation workarounds */
          #ifndef __always_inline
          #define __always_inline inline
          #endif
          #ifndef __user
          #define __user
          #endif
          #ifndef __kernel
          #define __kernel
          #endif
          #ifndef __force
          #define __force
          #endif
          #ifndef __must_check
          #define __must_check
          #endif
          #ifndef __cold
          #define __cold
          #endif
          #ifndef __noreturn
          #define __noreturn
          #endif
          #ifndef __section
          #define __section(x)
          #endif
          #ifndef __latent_entropy
          #define __latent_entropy
          #endif
          #ifndef __noinitretpoline
          #define __noinitretpoline
          #endif
          #ifndef __no_sanitize_or_inline
          #define __no_sanitize_or_inline inline
          #endif
          #ifndef __no_kasan_or_inline
          #define __no_kasan_or_inline inline
          #endif
          #ifndef __realloc_size
          #define __realloc_size(x, ...)
          #endif
          #ifndef __unqual_scalar_typeof
          #define __unqual_scalar_typeof(x) typeof(x)
          #endif
          #ifndef __counted_by
          #define __counted_by(x)
          #endif
          #ifndef __member_size
          #define __member_size(p) 0
          #endif
          #ifndef __struct_size
          #define __struct_size(p) 0
          #endif
          #ifndef __fortify_panic
          #define __fortify_panic(reason, avail, size) abort()
          #endif
          #ifndef fortify_panic
          #define fortify_panic(func, write, avail, size, p) abort()
          #endif
          EOF
      
          # Fix init.h empty macro
          INIT_FILE="common/include/linux/init.h"
          [ -f "$INIT_FILE" ] && sed -i '/^#define $/d' "$INIT_FILE"
      
          # Fix capability.h typedef
          CAPABILITY_FILE="common/include/uapi/linux/capability.h"
          sed -i 's/typedef struct __user_cap_header_struct {/struct __user_cap_header_struct {/' "$CAPABILITY_FILE"
          sed -i '/struct __user_cap_header_struct {/a typedef struct __user_cap_header_struct *cap_user_header_t;' "$CAPABILITY_FILE"
          sed -i 's/typedef struct __user_cap_data_struct __user \*cap_user_data_t;/typedef struct __user_cap_data_struct *cap_user_data_t;/' "$CAPABILITY_FILE"
      
          # Fix ftrace likely data declaration
          FTRACE_FILE="common/include/linux/compiler.h"
          [ -f "$FTRACE_FILE" ] && sed -i 's/struct ftrace_likely_data \*f/void \*f/' "$FTRACE_FILE"
      
          echo "✅ Applied comprehensive kernel headers patch"
      - name: 🔧 Set compiler flags
        run: |
          echo "CFLAGS += -Wno-error=macro-redefined -Wno-macro-redefined -Wno-error=visibility -Wno-visibility" >> $GITHUB_ENV
          echo "EXTRA_CFLAGS += -Wno-error=macro-redefined -Wno-macro-redefined -Wno-error=visibility -Wno-visibility" >> $GITHUB_ENV
      - name: 🛠️ Patch fortify-string.h
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          FORTIFY_FILE="common/include/linux/fortify-string.h"
          [ -f "$FORTIFY_FILE" ] && sed -i 's/__fortify_panic(/abort(); \/\/ __fortify_panic(/' "$FORTIFY_FILE"
          [ -f "$FORTIFY_FILE" ] && sed -i 's/__struct_size(p)/sizeof(*p)/g' "$FORTIFY_FILE"
      - name: 🛠️ Fix capability.h typedef syntax
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          CAPABILITY_FILE="common/include/uapi/linux/capability.h"
          
          # Backup original file
          cp "$CAPABILITY_FILE" "${CAPABILITY_FILE}.orig"
          
          # Apply the fix by separating struct definition and typedef
          sed -i 's/typedef struct __user_cap_header_struct {/struct __user_cap_header_struct {/' "$CAPABILITY_FILE"
          sed -i '/struct __user_cap_header_struct {/a typedef struct __user_cap_header_struct *cap_user_header_t;' "$CAPABILITY_FILE"
          
          # Also fix the cap_user_data_t typedef
          sed -i 's/typedef struct __user_cap_data_struct __user \*cap_user_data_t;/typedef struct __user_cap_data_struct *cap_user_data_t;/' "$CAPABILITY_FILE"
          
          echo "✅ Fixed capability.h typedef syntax"
      - name: 🛠️ Fix duplicate typedefs in capability.h
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          CAPABILITY_FILE="common/include/uapi/linux/capability.h"
          
          # Backup original file
          cp "$CAPABILITY_FILE" "${CAPABILITY_FILE}.bak"
          
          # Remove all existing typedef declarations
          sed -i '/typedef struct __user_cap_header_struct \*cap_user_header_t;/d' "$CAPABILITY_FILE"
          sed -i '/typedef struct __user_cap_data_struct __user \*cap_user_data_t;/d' "$CAPABILITY_FILE"
          
          # Add clean typedef declarations after struct definitions
          sed -i '/struct __user_cap_header_struct {/a typedef struct __user_cap_header_struct *cap_user_header_t;' "$CAPABILITY_FILE"
          sed -i '/struct __user_cap_data_struct {/a typedef struct __user_cap_data_struct *cap_user_data_t;' "$CAPABILITY_FILE"
          
          # Ensure only one copy of each typedef exists
          awk '!seen[$0]++' "$CAPABILITY_FILE" > "${CAPABILITY_FILE}.tmp" && mv "${CAPABILITY_FILE}.tmp" "$CAPABILITY_FILE"
          
          echo "✅ Removed duplicate typedefs from capability.h"
      - name: 🛠️ Fix capability.h header
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Create a clean version of capability.h
          cat << 'EOF' > "common/include/uapi/linux/capability.h"
          #ifndef _LINUX_CAPABILITY_H
          #define _LINUX_CAPABILITY_H
          
          #include <linux/types.h>
          
          struct __user_cap_header_struct {
              __u32 version;
              int pid;
          };
          
          struct __user_cap_data_struct {
              __u32 effective;
              __u32 permitted;
              __u32 inheritable;
          };
          
          typedef struct __user_cap_header_struct *cap_user_header_t;
          typedef struct __user_cap_data_struct *cap_user_data_t;
          
          #define _LINUX_CAPABILITY_VERSION_1  0x19980330
          #define _LINUX_CAPABILITY_U32S_1     1
          
          #define _LINUX_CAPABILITY_VERSION_2  0x20071026
          #define _LINUX_CAPABILITY_U32S_2     2
          
          #define _LINUX_CAPABILITY_VERSION_3  0x20080522
          #define _LINUX_CAPABILITY_U32S_3     2
          
          #endif /* _LINUX_CAPABILITY_H */
          EOF
      - name: 🛠️ Fix socket.h header
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Add typedef before struct definition
          sed -i '1i typedef unsigned short __kernel_sa_family_t;' "common/include/uapi/linux/socket.h"
      - name: 🛠️ Fix SELinux headers
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Fix classmap.h
          CLASSMAP="common/security/selinux/include/classmap.h"
          sed -i 's/const struct security_class_mapping secclass_map\[\]/extern const struct security_class_mapping secclass_map[]/' "$CLASSMAP"
          
          # Fix initial_sid_to_string.h
          INIT_SID="common/security/selinux/include/initial_sid_to_string.h"
          sed -i 's/static const char \*const initial_sid_to_string\[\]/extern const char *const initial_sid_to_string[]/' "$INIT_SID"
      - name: 🛠️ Fix genheaders.c
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          GENHEADERS="common/scripts/selinux/genheaders/genheaders.c"
          # Remove static from usage function
          sed -i 's/static void usage(void)/void usage(void)/' "$GENHEADERS"
          
          # Add missing includes
          sed -i '1i #include <stdlib.h>' "$GENHEADERS"
          sed -i '1i #include <string.h>' "$GENHEADERS"
      - name: 🛠️ Add compiler workarounds
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Create compiler.h workarounds
          cat << 'EOF' >> "common/include/linux/compiler.h"
          #ifndef __user
          #define __user
          #endif
          #ifndef __kernel
          #define __kernel
          #endif
          #ifndef __force
          #define __force
          #endif
          #ifndef __must_check
          #define __must_check
          #endif
          #ifndef __always_inline
          #define __always_inline inline
          #endif
          EOF
          
      - name: Create complete atomic-long.h (with direct include)
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          mkdir -p common/include/linux/atomic
          cat << EOF > common/include/linux/atomic/atomic-long.h
          #ifndef _LINUX_ATOMIC_LONG_H
          #define _LINUX_ATOMIC_LONG_H

          #include <linux/compiler.h>
          #include <linux/types.h>
          #include <asm-generic/atomic-long.h>
          // Include atomic-raw64-compat.h *directly* here. This is
          // the most reliable way to make the raw_atomic64_* functions
          // available.
          #include <linux/atomic/atomic-raw64-compat.h>

          #ifdef CONFIG_64BIT
          typedef atomic64_t atomic_long_t;
          #define ATOMIC_LONG_INIT(i)        ATOMIC64_INIT(i)
          #else
          typedef atomic_t atomic_long_t;
          #define ATOMIC_LONG_INIT(i)        ATOMIC_INIT(i)
          #endif

            static inline long raw_atomic_long_read(const atomic_long_t *v)
            {
                return raw_atomic64_read(v);
            }

            static inline void raw_atomic_long_set(atomic_long_t *v, long i)
            {
                raw_atomic64_set(v,i);
            }

            static inline void raw_atomic_long_add(long i, atomic_long_t *v)
            {
                raw_atomic64_add(i,v);
            }
            static inline long raw_atomic_long_add_return(long i, atomic_long_t *v)
            {
                return raw_atomic64_add_return(i,v);
            }
             static inline long raw_atomic_long_add_return_acquire(long i, atomic_long_t *v)
            {
                return raw_atomic64_add_return_acquire(i,v);
            }
             static inline long raw_atomic_long_add_return_release(long i, atomic_long_t *v)
            {
                return raw_atomic64_add_return_release(i,v);
            }
             static inline long raw_atomic_long_add_return_relaxed(long i, atomic_long_t *v)
            {
                return raw_atomic64_add_return_relaxed(i,v);
            }
            static inline long raw_atomic_long_fetch_add(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_add(i,v);
            }
            static inline long raw_atomic_long_fetch_add_acquire(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_add_acquire(i,v);
            }
            static inline long raw_atomic_long_fetch_add_release(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_add_release(i,v);
            }
             static inline long raw_atomic_long_fetch_add_relaxed(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_add_relaxed(i,v);
            }
            static inline void raw_atomic_long_sub(long i, atomic_long_t *v)
            {
                raw_atomic64_sub(i,v);
            }
            static inline long raw_atomic_long_sub_return(long i, atomic_long_t *v)
            {
               return  raw_atomic64_sub_return(i,v);
            }
             static inline long raw_atomic_long_sub_return_acquire(long i, atomic_long_t *v)
            {
               return  raw_atomic64_sub_return_acquire(i,v);
            }
             static inline long raw_atomic_long_sub_return_release(long i, atomic_long_t *v)
            {
               return raw_atomic64_sub_return_release(i,v);
            }
             static inline long raw_atomic_long_sub_return_relaxed(long i, atomic_long_t *v)
            {
                return raw_atomic64_sub_return_relaxed(i,v);
            }
            static inline long raw_atomic_long_fetch_sub(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_sub(i,v);
            }
             static inline long raw_atomic_long_fetch_sub_acquire(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_sub_acquire(i,v);
            }
            static inline long raw_atomic_long_fetch_sub_release(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_sub_release(i,v);
            }
            static inline long raw_atomic_long_fetch_sub_relaxed(long i, atomic_long_t *v)
            {
               return raw_atomic64_fetch_sub_relaxed(i,v);
            }
            static inline void raw_atomic_long_inc(atomic_long_t *v)
            {
                raw_atomic64_inc(v);
            }
            static inline long raw_atomic_long_inc_return(atomic_long_t *v){
                return raw_atomic64_inc_return(v);
            }
            static inline long raw_atomic_long_fetch_inc(atomic_long_t *v){
               return raw_atomic64_fetch_inc(v);
            }
            static inline void raw_atomic_long_dec(atomic_long_t *v)
            {
              raw_atomic64_dec(v);
            }
            static inline long raw_atomic_long_dec_return(atomic_long_t *v){
                return raw_atomic64_dec_return(v);
            }
            static inline long raw_atomic_long_fetch_dec(atomic_long_t *v){
                return raw_atomic64_fetch_dec(v);
            }
            static inline void raw_atomic_long_and(long i, atomic_long_t *v){
                raw_atomic64_and(i,v);
            }
            static inline long raw_atomic_long_fetch_and(long i, atomic_long_t *v){
               return raw_atomic64_fetch_and(i,v);
            }
            static inline void raw_atomic_long_andnot(long i, atomic_long_t *v){
                raw_atomic64_andnot(i,v);
            }
             static inline long raw_atomic_long_fetch_andnot(long i, atomic_long_t *v){
               return  raw_atomic64_fetch_andnot(i,v);
            }
            static inline void raw_atomic_long_or(long i, atomic_long_t *v){
                raw_atomic64_or(i,v);
            }
            static inline long raw_atomic_long_fetch_or(long i, atomic_long_t *v){
                return raw_atomic64_fetch_or(i,v);
            }
            static inline void raw_atomic_long_xor(long i, atomic_long_t *v){
                raw_atomic64_xor(i,v);
            }
            static inline long raw_atomic_long_fetch_xor(long i, atomic_long_t *v){
               return raw_atomic64_fetch_xor(i,v);
            }
            static inline long raw_atomic_long_xchg(atomic_long_t *v, long new){
             return raw_atomic64_xchg(v,new);
            }
            static inline long raw_atomic_long_cmpxchg(atomic_long_t *v, long old, long new){
             return raw_atomic64_cmpxchg(v,old,new);
            }
            static inline bool raw_atomic_long_try_cmpxchg(atomic_long_t *v, long *old, long new){
            return  raw_atomic64_try_cmpxchg(v,old,new);
            }
            static inline bool raw_atomic_long_sub_and_test(long i, atomic_long_t *v){
                return raw_atomic64_sub_and_test(i,v);
            }
             static inline bool raw_atomic_long_dec_and_test(atomic_long_t *v){
                return raw_atomic64_dec_and_test(v);
            }
            static inline bool raw_atomic_long_inc_and_test(atomic_long_t *v){
                return raw_atomic64_inc_and_test(v);
            }
             static inline bool raw_atomic_long_add_negative(long i, atomic_long_t *v){
                return raw_atomic64_add_negative(i,v);
            }
            static inline long raw_atomic_long_fetch_add_unless(atomic_long_t *v, long a, long u){
                return raw_atomic64_fetch_add_unless(v,a,u);
            }
            static inline bool raw_atomic_long_add_unless(atomic_long_t *v, long a, long u){
                return raw_atomic64_add_unless(v,a,u);
            }
             static inline bool raw_atomic_long_inc_not_zero(atomic_long_t *v){
                return raw_atomic64_inc_not_zero(v);
            }
            static inline bool raw_atomic_long_inc_unless_negative(atomic_long_t *v){
                return raw_atomic64_inc_unless_negative(v);
            }
            static inline bool raw_atomic_long_dec_unless_positive(atomic_long_t *v){
                return raw_atomic64_dec_unless_positive(v);
            }
            static inline long raw_atomic_long_dec_if_positive(atomic_long_t *v){
             return raw_atomic64_dec_if_positive(v);
            }
          #endif
          EOF

          echo "✅ Fixed kernel header compilation issues and created atomic-long.h"
      - name: 📥 Create atomic-raw64-compat.h with all atomic64 operations
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          mkdir -p common/include/linux/atomic
          cat << 'EOF' > common/include/linux/atomic/atomic-raw64-compat.h
          #ifndef _LINUX_ATOMIC_RAW64_COMPAT_H
          #define _LINUX_ATOMIC_RAW64_COMPAT_H
      
          #include <linux/types.h>
          #include <linux/compiler.h>
      
          #ifndef raw_atomic64_read
          static inline s64 raw_atomic64_read(const atomic64_t *v)
          {
              return atomic64_read(v);
          }
          #endif
      
          #ifndef raw_atomic64_read_acquire
          static inline s64 raw_atomic64_read_acquire(const atomic64_t *v)
          {
              return atomic64_read_acquire(v);
          }
          #endif
      
          #ifndef raw_atomic64_set
          static inline void raw_atomic64_set(atomic64_t *v, s64 i)
          {
              atomic64_set(v, i);
          }
          #endif
      
          #ifndef raw_atomic64_set_release
          static inline void raw_atomic64_set_release(atomic64_t *v, s64 i)
          {
              atomic64_set_release(v, i);
          }
          #endif
      
          #ifndef raw_atomic64_add
          static inline void raw_atomic64_add(s64 i, atomic64_t *v)
          {
              atomic64_add(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_add_return
          static inline s64 raw_atomic64_add_return(s64 i, atomic64_t *v)
          {
              return atomic64_add_return(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_add_return_acquire
          static inline s64 raw_atomic64_add_return_acquire(s64 i, atomic64_t *v)
          {
              return atomic64_add_return_acquire(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_add_return_release
          static inline s64 raw_atomic64_add_return_release(s64 i, atomic64_t *v)
          {
              return atomic64_add_return_release(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_add_return_relaxed
          static inline s64 raw_atomic64_add_return_relaxed(s64 i, atomic64_t *v)
          {
              return atomic64_add_return_relaxed(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_add
          static inline s64 raw_atomic64_fetch_add(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_add(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_add_acquire
          static inline s64 raw_atomic64_fetch_add_acquire(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_add_acquire(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_add_release
          static inline s64 raw_atomic64_fetch_add_release(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_add_release(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_add_relaxed
          static inline s64 raw_atomic64_fetch_add_relaxed(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_add_relaxed(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_sub
          static inline void raw_atomic64_sub(s64 i, atomic64_t *v)
          {
              atomic64_sub(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_sub_return
          static inline s64 raw_atomic64_sub_return(s64 i, atomic64_t *v)
          {
              return atomic64_sub_return(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_sub_return_acquire
          static inline s64 raw_atomic64_sub_return_acquire(s64 i, atomic64_t *v)
          {
              return atomic64_sub_return_acquire(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_sub_return_release
          static inline s64 raw_atomic64_sub_return_release(s64 i, atomic64_t *v)
          {
              return atomic64_sub_return_release(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_sub_return_relaxed
          static inline s64 raw_atomic64_sub_return_relaxed(s64 i, atomic64_t *v)
          {
              return atomic64_sub_return_relaxed(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_sub
          static inline s64 raw_atomic64_fetch_sub(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_sub(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_sub_acquire
          static inline s64 raw_atomic64_fetch_sub_acquire(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_sub_acquire(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_sub_release
          static inline s64 raw_atomic64_fetch_sub_release(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_sub_release(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_sub_relaxed
          static inline s64 raw_atomic64_fetch_sub_relaxed(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_sub_relaxed(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_inc
          static inline void raw_atomic64_inc(atomic64_t *v)
          {
              atomic64_inc(v);
          }
          #endif
      
          #ifndef raw_atomic64_inc_return
          static inline s64 raw_atomic64_inc_return(atomic64_t *v)
          {
              return atomic64_inc_return(v);
          }
          #endif
      
          #ifndef raw_atomic64_inc_return_acquire
          static inline s64 raw_atomic64_inc_return_acquire(atomic64_t *v)
          {
              return atomic64_inc_return_acquire(v);
          }
          #endif
      
          #ifndef raw_atomic64_inc_return_release
          static inline s64 raw_atomic64_inc_return_release(atomic64_t *v)
          {
              return atomic64_inc_return_release(v);
          }
          #endif
      
          #ifndef raw_atomic64_inc_return_relaxed
          static inline s64 raw_atomic64_inc_return_relaxed(atomic64_t *v)
          {
              return atomic64_inc_return_relaxed(v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_inc
          static inline s64 raw_atomic64_fetch_inc(atomic64_t *v)
          {
              return atomic64_fetch_inc(v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_inc_acquire
          static inline s64 raw_atomic64_fetch_inc_acquire(atomic64_t *v)
          {
              return atomic64_fetch_inc_acquire(v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_inc_release
          static inline s64 raw_atomic64_fetch_inc_release(atomic64_t *v)
          {
              return atomic64_fetch_inc_release(v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_inc_relaxed
          static inline s64 raw_atomic64_fetch_inc_relaxed(atomic64_t *v)
          {
              return atomic64_fetch_inc_relaxed(v);
          }
          #endif
      
          #ifndef raw_atomic64_dec
          static inline void raw_atomic64_dec(atomic64_t *v)
          {
              atomic64_dec(v);
          }
          #endif
      
          #ifndef raw_atomic64_dec_return
          static inline s64 raw_atomic64_dec_return(atomic64_t *v)
          {
              return atomic64_dec_return(v);
          }
          #endif
      
          #ifndef raw_atomic64_dec_return_acquire
          static inline s64 raw_atomic64_dec_return_acquire(atomic64_t *v)
          {
              return atomic64_dec_return_acquire(v);
          }
          #endif
      
          #ifndef raw_atomic64_dec_return_release
          static inline s64 raw_atomic64_dec_return_release(atomic64_t *v)
          {
              return atomic64_dec_return_release(v);
          }
          #endif
      
          #ifndef raw_atomic64_dec_return_relaxed
          static inline s64 raw_atomic64_dec_return_relaxed(atomic64_t *v)
          {
              return atomic64_dec_return_relaxed(v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_dec
          static inline s64 raw_atomic64_fetch_dec(atomic64_t *v)
          {
              return atomic64_fetch_dec(v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_dec_acquire
          static inline s64 raw_atomic64_fetch_dec_acquire(atomic64_t *v)
          {
              return atomic64_fetch_dec_acquire(v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_dec_release
          static inline s64 raw_atomic64_fetch_dec_release(atomic64_t *v)
          {
              return atomic64_fetch_dec_release(v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_dec_relaxed
          static inline s64 raw_atomic64_fetch_dec_relaxed(atomic64_t *v)
          {
              return atomic64_fetch_dec_relaxed(v);
          }
          #endif
      
          #ifndef raw_atomic64_and
          static inline void raw_atomic64_and(s64 i, atomic64_t *v)
          {
              atomic64_and(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_and
          static inline s64 raw_atomic64_fetch_and(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_and(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_and_acquire
          static inline s64 raw_atomic64_fetch_and_acquire(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_and_acquire(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_and_release
          static inline s64 raw_atomic64_fetch_and_release(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_and_release(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_and_relaxed
          static inline s64 raw_atomic64_fetch_and_relaxed(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_and_relaxed(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_andnot
          static inline void raw_atomic64_andnot(s64 i, atomic64_t *v)
          {
              atomic64_andnot(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_andnot
          static inline s64 raw_atomic64_fetch_andnot(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_andnot(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_andnot_acquire
          static inline s64 raw_atomic64_fetch_andnot_acquire(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_andnot_acquire(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_andnot_release
          static inline s64 raw_atomic64_fetch_andnot_release(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_andnot_release(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_andnot_relaxed
          static inline s64 raw_atomic64_fetch_andnot_relaxed(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_andnot_relaxed(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_or
          static inline void raw_atomic64_or(s64 i, atomic64_t *v)
          {
              atomic64_or(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_or
          static inline s64 raw_atomic64_fetch_or(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_or(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_or_acquire
          static inline s64 raw_atomic64_fetch_or_acquire(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_or_acquire(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_or_release
          static inline s64 raw_atomic64_fetch_or_release(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_or_release(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_or_relaxed
          static inline s64 raw_atomic64_fetch_or_relaxed(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_or_relaxed(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_xor
          static inline void raw_atomic64_xor(s64 i, atomic64_t *v)
          {
              atomic64_xor(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_xor
          static inline s64 raw_atomic64_fetch_xor(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_xor(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_xor_acquire
          static inline s64 raw_atomic64_fetch_xor_acquire(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_xor_acquire(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_xor_release
          static inline s64 raw_atomic64_fetch_xor_release(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_xor_release(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_xor_relaxed
          static inline s64 raw_atomic64_fetch_xor_relaxed(s64 i, atomic64_t *v)
          {
              return atomic64_fetch_xor_relaxed(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_xchg
          static inline s64 raw_atomic64_xchg(atomic64_t *v, s64 new)
          {
              return atomic64_xchg(v, new);
          }
          #endif
      
          #ifndef raw_atomic64_xchg_acquire
          static inline s64 raw_atomic64_xchg_acquire(atomic64_t *v, s64 new)
          {
              return atomic64_xchg_acquire(v, new);
          }
          #endif
      
          #ifndef raw_atomic64_xchg_release
          static inline s64 raw_atomic64_xchg_release(atomic64_t *v, s64 new)
          {
              return atomic64_xchg_release(v, new);
          }
          #endif
      
          #ifndef raw_atomic64_xchg_relaxed
          static inline s64 raw_atomic64_xchg_relaxed(atomic64_t *v, s64 new)
          {
              return atomic64_xchg_relaxed(v, new);
          }
          #endif
      
          #ifndef raw_atomic64_cmpxchg
          static inline s64 raw_atomic64_cmpxchg(atomic64_t *v, s64 old, s64 new)
          {
              return atomic64_cmpxchg(v, old, new);
          }
          #endif
      
          #ifndef raw_atomic64_cmpxchg_acquire
          static inline s64 raw_atomic64_cmpxchg_acquire(atomic64_t *v, s64 old, s64 new)
          {
              return atomic64_cmpxchg_acquire(v, old, new);
          }
          #endif
      
          #ifndef raw_atomic64_cmpxchg_release
          static inline s64 raw_atomic64_cmpxchg_release(atomic64_t *v, s64 old, s64 new)
          {
              return atomic64_cmpxchg_release(v, old, new);
          }
          #endif
      
          #ifndef raw_atomic64_cmpxchg_relaxed
          static inline s64 raw_atomic64_cmpxchg_relaxed(atomic64_t *v, s64 old, s64 new)
          {
              return atomic64_cmpxchg_relaxed(v, old, new);
          }
          #endif
      
          #ifndef raw_atomic64_try_cmpxchg
          static inline bool raw_atomic64_try_cmpxchg(atomic64_t *v, s64 *old, s64 new)
          {
              return atomic64_try_cmpxchg(v, old, new);
          }
          #endif
      
          #ifndef raw_atomic64_try_cmpxchg_acquire
          static inline bool raw_atomic64_try_cmpxchg_acquire(atomic64_t *v, s64 *old, s64 new)
          {
              return atomic64_try_cmpxchg_acquire(v, old, new);
          }
          #endif
      
          #ifndef raw_atomic64_try_cmpxchg_release
          static inline bool raw_atomic64_try_cmpxchg_release(atomic64_t *v, s64 *old, s64 new)
          {
              return atomic64_try_cmpxchg_release(v, old, new);
          }
          #endif
      
          #ifndef raw_atomic64_try_cmpxchg_relaxed
          static inline bool raw_atomic64_try_cmpxchg_relaxed(atomic64_t *v, s64 *old, s64 new)
          {
              return atomic64_try_cmpxchg_relaxed(v, old, new);
          }
          #endif
      
          #ifndef raw_atomic64_sub_and_test
          static inline bool raw_atomic64_sub_and_test(s64 i, atomic64_t *v)
          {
              return atomic64_sub_and_test(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_dec_and_test
          static inline bool raw_atomic64_dec_and_test(atomic64_t *v)
          {
              return atomic64_dec_and_test(v);
          }
          #endif
      
          #ifndef raw_atomic64_inc_and_test
          static inline bool raw_atomic64_inc_and_test(atomic64_t *v)
          {
              return atomic64_inc_and_test(v);
          }
          #endif
      
          #ifndef raw_atomic64_add_negative
          static inline bool raw_atomic64_add_negative(s64 i, atomic64_t *v)
          {
              return atomic64_add_negative(i, v);
          }
          #endif
      
          #ifndef raw_atomic64_fetch_add_unless
          static inline s64 raw_atomic64_fetch_add_unless(atomic64_t *v, s64 a, s64 u)
          {
              return atomic64_fetch_add_unless(v, a, u);
          }
          #endif
      
          #ifndef raw_atomic64_add_unless
          static inline bool raw_atomic64_add_unless(atomic64_t *v, s64 a, s64 u)
          {
              return atomic64_add_unless(v, a, u);
          }
          #endif
      
          #ifndef raw_atomic64_inc_not_zero
          static inline bool raw_atomic64_inc_not_zero(atomic64_t *v)
          {
              return atomic64_inc_not_zero(v);
          }
          #endif
      
          #ifndef raw_atomic64_inc_unless_negative
          static inline bool raw_atomic64_inc_unless_negative(atomic64_t *v)
          {
              return atomic64_inc_unless_negative(v);
          }
          #endif
      
          #ifndef raw_atomic64_dec_unless_positive
          static inline bool raw_atomic64_dec_unless_positive(atomic64_t *v)
          {
              return atomic64_dec_unless_positive(v);
          }
          #endif
      
          #ifndef raw_atomic64_dec_if_positive
          static inline s64 raw_atomic64_dec_if_positive(atomic64_t *v)
          {
              return atomic64_dec_if_positive(v);
          }
          #endif
      
          #endif /* _LINUX_ATOMIC_RAW64_COMPAT_H */
          EOF
      - name: 🩹 Patch atomic-long.h with complete atomic operations
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          mkdir -p common/include/linux/atomic
          cat << 'EOF' > common/include/linux/atomic/atomic-long.h
          #ifndef _LINUX_ATOMIC_LONG_H
          #define _LINUX_ATOMIC_LONG_H
      
          #include <linux/compiler.h>
          #include <linux/types.h>
          #include <asm-generic/atomic-long.h>
          #include <linux/atomic/atomic-raw64-compat.h>
      
          #ifdef CONFIG_64BIT
          typedef atomic64_t atomic_long_t;
          #define ATOMIC_LONG_INIT(i)        ATOMIC64_INIT(i)
          #define ATOMIC_LONG_PFX(x)         atomic64##x
      
          /* 64-bit atomic_long operations */
          static inline long raw_atomic_long_read(const atomic_long_t *v)
          {
              return raw_atomic64_read(v);
          }
      
          static inline long raw_atomic_long_read_acquire(const atomic_long_t *v)
          {
              return raw_atomic64_read_acquire(v);
          }
      
          static inline void raw_atomic_long_set(atomic_long_t *v, long i)
          {
              raw_atomic64_set(v, i);
          }
      
          static inline void raw_atomic_long_set_release(atomic_long_t *v, long i)
          {
              raw_atomic64_set_release(v, i);
          }
      
          static inline void raw_atomic_long_add(long i, atomic_long_t *v)
          {
              raw_atomic64_add(i, v);
          }
      
          static inline long raw_atomic_long_add_return(long i, atomic_long_t *v)
          {
              return raw_atomic64_add_return(i, v);
          }
      
          static inline long raw_atomic_long_add_return_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic64_add_return_acquire(i, v);
          }
      
          static inline long raw_atomic_long_add_return_release(long i, atomic_long_t *v)
          {
              return raw_atomic64_add_return_release(i, v);
          }
      
          static inline long raw_atomic_long_add_return_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic64_add_return_relaxed(i, v);
          }
      
          static inline long raw_atomic_long_fetch_add(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_add(i, v);
          }
      
          static inline long raw_atomic_long_fetch_add_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_add_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_add_release(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_add_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_add_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_add_relaxed(i, v);
          }
      
          static inline void raw_atomic_long_sub(long i, atomic_long_t *v)
          {
              raw_atomic64_sub(i, v);
          }
      
          static inline long raw_atomic_long_sub_return(long i, atomic_long_t *v)
          {
              return raw_atomic64_sub_return(i, v);
          }
      
          static inline long raw_atomic_long_sub_return_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic64_sub_return_acquire(i, v);
          }
      
          static inline long raw_atomic_long_sub_return_release(long i, atomic_long_t *v)
          {
              return raw_atomic64_sub_return_release(i, v);
          }
      
          static inline long raw_atomic_long_sub_return_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic64_sub_return_relaxed(i, v);
          }
      
          static inline long raw_atomic_long_fetch_sub(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_sub(i, v);
          }
      
          static inline long raw_atomic_long_fetch_sub_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_sub_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_sub_release(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_sub_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_sub_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_sub_relaxed(i, v);
          }
      
          static inline void raw_atomic_long_inc(atomic_long_t *v)
          {
              raw_atomic64_inc(v);
          }
      
          static inline long raw_atomic_long_inc_return(atomic_long_t *v)
          {
              return raw_atomic64_inc_return(v);
          }
      
          static inline long raw_atomic_long_inc_return_acquire(atomic_long_t *v)
          {
              return raw_atomic64_inc_return_acquire(v);
          }
      
          static inline long raw_atomic_long_inc_return_release(atomic_long_t *v)
          {
              return raw_atomic64_inc_return_release(v);
          }
      
          static inline long raw_atomic_long_inc_return_relaxed(atomic_long_t *v)
          {
              return raw_atomic64_inc_return_relaxed(v);
          }
      
          static inline long raw_atomic_long_fetch_inc(atomic_long_t *v)
          {
              return raw_atomic64_fetch_inc(v);
          }
      
          static inline long raw_atomic_long_fetch_inc_acquire(atomic_long_t *v)
          {
              return raw_atomic64_fetch_inc_acquire(v);
          }
      
          static inline long raw_atomic_long_fetch_inc_release(atomic_long_t *v)
          {
              return raw_atomic64_fetch_inc_release(v);
          }
      
          static inline long raw_atomic_long_fetch_inc_relaxed(atomic_long_t *v)
          {
              return raw_atomic64_fetch_inc_relaxed(v);
          }
      
          static inline void raw_atomic_long_dec(atomic_long_t *v)
          {
              raw_atomic64_dec(v);
          }
      
          static inline long raw_atomic_long_dec_return(atomic_long_t *v)
          {
              return raw_atomic64_dec_return(v);
          }
      
          static inline long raw_atomic_long_dec_return_acquire(atomic_long_t *v)
          {
              return raw_atomic64_dec_return_acquire(v);
          }
      
          static inline long raw_atomic_long_dec_return_release(atomic_long_t *v)
          {
              return raw_atomic64_dec_return_release(v);
          }
      
          static inline long raw_atomic_long_dec_return_relaxed(atomic_long_t *v)
          {
              return raw_atomic64_dec_return_relaxed(v);
          }
      
          static inline long raw_atomic_long_fetch_dec(atomic_long_t *v)
          {
              return raw_atomic64_fetch_dec(v);
          }
      
          static inline long raw_atomic_long_fetch_dec_acquire(atomic_long_t *v)
          {
              return raw_atomic64_fetch_dec_acquire(v);
          }
      
          static inline long raw_atomic_long_fetch_dec_release(atomic_long_t *v)
          {
              return raw_atomic64_fetch_dec_release(v);
          }
      
          static inline long raw_atomic_long_fetch_dec_relaxed(atomic_long_t *v)
          {
              return raw_atomic64_fetch_dec_relaxed(v);
          }
      
          static inline void raw_atomic_long_and(long i, atomic_long_t *v)
          {
              raw_atomic64_and(i, v);
          }
      
          static inline long raw_atomic_long_fetch_and(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_and(i, v);
          }
      
          static inline long raw_atomic_long_fetch_and_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_and_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_and_release(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_and_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_and_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_and_relaxed(i, v);
          }
      
          static inline void raw_atomic_long_andnot(long i, atomic_long_t *v)
          {
              raw_atomic64_andnot(i, v);
          }
      
          static inline long raw_atomic_long_fetch_andnot(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_andnot(i, v);
          }
      
          static inline long raw_atomic_long_fetch_andnot_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_andnot_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_andnot_release(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_andnot_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_andnot_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_andnot_relaxed(i, v);
          }
      
          static inline void raw_atomic_long_or(long i, atomic_long_t *v)
          {
              raw_atomic64_or(i, v);
          }
      
          static inline long raw_atomic_long_fetch_or(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_or(i, v);
          }
      
          static inline long raw_atomic_long_fetch_or_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_or_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_or_release(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_or_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_or_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_or_relaxed(i, v);
          }
      
          static inline void raw_atomic_long_xor(long i, atomic_long_t *v)
          {
              raw_atomic64_xor(i, v);
          }
      
          static inline long raw_atomic_long_fetch_xor(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_xor(i, v);
          }
      
          static inline long raw_atomic_long_fetch_xor_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_xor_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_xor_release(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_xor_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_xor_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_xor_relaxed(i, v);
          }
      
          static inline long raw_atomic_long_xchg(atomic_long_t *v, long new)
          {
              return raw_atomic64_xchg(v, new);
          }
      
          static inline long raw_atomic_long_xchg_acquire(atomic_long_t *v, long new)
          {
              return raw_atomic64_xchg_acquire(v, new);
          }
      
          static inline long raw_atomic_long_xchg_release(atomic_long_t *v, long new)
          {
              return raw_atomic64_xchg_release(v, new);
          }
      
          static inline long raw_atomic_long_xchg_relaxed(atomic_long_t *v, long new)
          {
              return raw_atomic64_xchg_relaxed(v, new);
          }
      
          static inline long raw_atomic_long_cmpxchg(atomic_long_t *v, long old, long new)
          {
              return raw_atomic64_cmpxchg(v, old, new);
          }
      
          static inline long raw_atomic_long_cmpxchg_acquire(atomic_long_t *v, long old, long new)
          {
              return raw_atomic64_cmpxchg_acquire(v, old, new);
          }
      
          static inline long raw_atomic_long_cmpxchg_release(atomic_long_t *v, long old, long new)
          {
              return raw_atomic64_cmpxchg_release(v, old, new);
          }
      
          static inline long raw_atomic_long_cmpxchg_relaxed(atomic_long_t *v, long old, long new)
          {
              return raw_atomic64_cmpxchg_relaxed(v, old, new);
          }
      
          static inline bool raw_atomic_long_try_cmpxchg(atomic_long_t *v, long *old, long new)
          {
              return raw_atomic64_try_cmpxchg(v, old, new);
          }
      
          static inline bool raw_atomic_long_try_cmpxchg_acquire(atomic_long_t *v, long *old, long new)
          {
              return raw_atomic64_try_cmpxchg_acquire(v, old, new);
          }
      
          static inline bool raw_atomic_long_try_cmpxchg_release(atomic_long_t *v, long *old, long new)
          {
              return raw_atomic64_try_cmpxchg_release(v, old, new);
          }
      
          static inline bool raw_atomic_long_try_cmpxchg_relaxed(atomic_long_t *v, long *old, long new)
          {
              return raw_atomic64_try_cmpxchg_relaxed(v, old, new);
          }
      
          static inline bool raw_atomic_long_sub_and_test(long i, atomic_long_t *v)
          {
              return raw_atomic64_sub_and_test(i, v);
          }
      
          static inline bool raw_atomic_long_dec_and_test(atomic_long_t *v)
          {
              return raw_atomic64_dec_and_test(v);
          }
      
          static inline bool raw_atomic_long_inc_and_test(atomic_long_t *v)
          {
              return raw_atomic64_inc_and_test(v);
          }
      
          static inline bool raw_atomic_long_add_negative(long i, atomic_long_t *v)
          {
              return raw_atomic64_add_negative(i, v);
          }
      
          static inline long raw_atomic_long_fetch_add_unless(atomic_long_t *v, long a, long u)
          {
              return raw_atomic64_fetch_add_unless(v, a, u);
          }
      
          static inline bool raw_atomic_long_add_unless(atomic_long_t *v, long a, long u)
          {
              return raw_atomic64_add_unless(v, a, u);
          }
      
          static inline bool raw_atomic_long_inc_not_zero(atomic_long_t *v)
          {
              return raw_atomic64_inc_not_zero(v);
          }
      
          static inline bool raw_atomic_long_inc_unless_negative(atomic_long_t *v)
          {
              return raw_atomic64_inc_unless_negative(v);
          }
      
          static inline bool raw_atomic_long_dec_unless_positive(atomic_long_t *v)
          {
              return raw_atomic64_dec_unless_positive(v);
          }
      
          static inline long raw_atomic_long_dec_if_positive(atomic_long_t *v)
          {
              return raw_atomic64_dec_if_positive(v);
          }
      
          #else /* CONFIG_64BIT */
          typedef atomic_t atomic_long_t;
          #define ATOMIC_LONG_INIT(i)        ATOMIC_INIT(i)
          #define ATOMIC_LONG_PFX(x)         atomic##x
      
          /* 32-bit atomic_long operations */
          static inline long raw_atomic_long_read(const atomic_long_t *v)
          {
              return raw_atomic_read(v);
          }
      
          static inline long raw_atomic_long_read_acquire(const atomic_long_t *v)
          {
              return raw_atomic_read_acquire(v);
          }
      
          static inline void raw_atomic_long_set(atomic_long_t *v, long i)
          {
              raw_atomic_set(v, i);
          }
      
          static inline void raw_atomic_long_set_release(atomic_long_t *v, long i)
          {
              raw_atomic_set_release(v, i);
          }
      
          static inline void raw_atomic_long_add(long i, atomic_long_t *v)
          {
              raw_atomic_add(i, v);
          }
      
          static inline long raw_atomic_long_add_return(long i, atomic_long_t *v)
          {
              return raw_atomic_add_return(i, v);
          }
      
          static inline long raw_atomic_long_add_return_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic_add_return_acquire(i, v);
          }
      
          static inline long raw_atomic_long_add_return_release(long i, atomic_long_t *v)
          {
              return raw_atomic_add_return_release(i, v);
          }
      
          static inline long raw_atomic_long_add_return_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic_add_return_relaxed(i, v);
          }
      
          static inline long raw_atomic_long_fetch_add(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_add(i, v);
          }
      
          static inline long raw_atomic_long_fetch_add_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_add_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_add_release(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_add_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_add_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_add_relaxed(i, v);
          }
      
          static inline void raw_atomic_long_sub(long i, atomic_long_t *v)
          {
              raw_atomic_sub(i, v);
          }
      
          static inline long raw_atomic_long_sub_return(long i, atomic_long_t *v)
          {
              return raw_atomic_sub_return(i, v);
          }
      
          static inline long raw_atomic_long_sub_return_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic_sub_return_acquire(i, v);
          }
      
          static inline long raw_atomic_long_sub_return_release(long i, atomic_long_t *v)
          {
              return raw_atomic_sub_return_release(i, v);
          }
      
          static inline long raw_atomic_long_sub_return_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic_sub_return_relaxed(i, v);
          }
      
          static inline long raw_atomic_long_fetch_sub(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_sub(i, v);
          }
      
          static inline long raw_atomic_long_fetch_sub_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_sub_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_sub_release(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_sub_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_sub_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_sub_relaxed(i, v);
          }
      
          static inline void raw_atomic_long_inc(atomic_long_t *v)
          {
              raw_atomic_inc(v);
          }
      
          static inline long raw_atomic_long_inc_return(atomic_long_t *v)
          {
              return raw_atomic_inc_return(v);
          }
      
          static inline long raw_atomic_long_inc_return_acquire(atomic_long_t *v)
          {
              return raw_atomic_inc_return_acquire(v);
          }
      
          static inline long raw_atomic_long_inc_return_release(atomic_long_t *v)
          {
              return raw_atomic_inc_return_release(v);
          }
      
          static inline long raw_atomic_long_inc_return_relaxed(atomic_long_t *v)
          {
              return raw_atomic_inc_return_relaxed(v);
          }
      
          static inline long raw_atomic_long_fetch_inc(atomic_long_t *v)
          {
              return raw_atomic_fetch_inc(v);
          }
      
          static inline long raw_atomic_long_fetch_inc_acquire(atomic_long_t *v)
          {
              return raw_atomic_fetch_inc_acquire(v);
          }
      
          static inline long raw_atomic_long_fetch_inc_release(atomic_long_t *v)
          {
              return raw_atomic_fetch_inc_release(v);
          }
      
          static inline long raw_atomic_long_fetch_inc_relaxed(atomic_long_t *v)
          {
              return raw_atomic_fetch_inc_relaxed(v);
          }
      
          static inline void raw_atomic_long_dec(atomic_long_t *v)
          {
              raw_atomic_dec(v);
          }
      
          static inline long raw_atomic_long_dec_return(atomic_long_t *v)
          {
              return raw_atomic_dec_return(v);
          }
      
          static inline long raw_atomic_long_dec_return_acquire(atomic_long_t *v)
          {
              return raw_atomic_dec_return_acquire(v);
          }
      
          static inline long raw_atomic_long_dec_return_release(atomic_long_t *v)
          {
              return raw_atomic_dec_return_release(v);
          }
      
          static inline long raw_atomic_long_dec_return_relaxed(atomic_long_t *v)
          {
              return raw_atomic_dec_return_relaxed(v);
          }
      
          static inline long raw_atomic_long_fetch_dec(atomic_long_t *v)
          {
              return raw_atomic_fetch_dec(v);
          }
      
          static inline long raw_atomic_long_fetch_dec_acquire(atomic_long_t *v)
          {
              return raw_atomic_fetch_dec_acquire(v);
          }
      
          static inline long raw_atomic_long_fetch_dec_release(atomic_long_t *v)
          {
              return raw_atomic_fetch_dec_release(v);
          }
      
          static inline long raw_atomic_long_fetch_dec_relaxed(atomic_long_t *v)
          {
              return raw_atomic_fetch_dec_relaxed(v);
          }
      
          static inline void raw_atomic_long_and(long i, atomic_long_t *v)
          {
              raw_atomic_and(i, v);
          }
      
          static inline long raw_atomic_long_fetch_and(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_and(i, v);
          }
      
          static inline long raw_atomic_long_fetch_and_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_and_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_and_release(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_and_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_and_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_and_relaxed(i, v);
          }
      
          static inline void raw_atomic_long_andnot(long i, atomic_long_t *v)
          {
              raw_atomic_andnot(i, v);
          }
      
          static inline long raw_atomic_long_fetch_andnot(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_andnot(i, v);
          }
      
          static inline long raw_atomic_long_fetch_andnot_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_andnot_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_andnot_release(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_andnot_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_andnot_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_andnot_relaxed(i, v);
          }
      
          static inline void raw_atomic_long_or(long i, atomic_long_t *v)
          {
              raw_atomic_or(i, v);
          }
      
          static inline long raw_atomic_long_fetch_or(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_or(i, v);
          }
      
          static inline long raw_atomic_long_fetch_or_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_or_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_or_release(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_or_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_or_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_or_relaxed(i, v);
          }
      
          static inline void raw_atomic_long_xor(long i, atomic_long_t *v)
          {
              raw_atomic_xor(i, v);
          }
      
          static inline long raw_atomic_long_fetch_xor(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_xor(i, v);
          }
      
          static inline long raw_atomic_long_fetch_xor_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_xor_acquire(i, v);
          }
      
          static inline long raw_atomic_long_fetch_xor_release(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_xor_release(i, v);
          }
      
          static inline long raw_atomic_long_fetch_xor_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic_fetch_xor_relaxed(i, v);
          }
      
          static inline long raw_atomic_long_xchg(atomic_long_t *v, long new)
          {
              return raw_atomic_xchg(v, new);
          }
      
          static inline long raw_atomic_long_xchg_acquire(atomic_long_t *v, long new)
          {
              return raw_atomic_xchg_acquire(v, new);
          }
      
          static inline long raw_atomic_long_xchg_release(atomic_long_t *v, long new)
          {
              return raw_atomic_xchg_release(v, new);
          }
      
          static inline long raw_atomic_long_xchg_relaxed(atomic_long_t *v, long new)
          {
              return raw_atomic_xchg_relaxed(v, new);
          }
      
          static inline long raw_atomic_long_cmpxchg(atomic_long_t *v, long old, long new)
          {
              return raw_atomic_cmpxchg(v, old, new);
          }
      
          static inline long raw_atomic_long_cmpxchg_acquire(atomic_long_t *v, long old, long new)
          {
              return raw_atomic_cmpxchg_acquire(v, old, new);
          }
      
          static inline long raw_atomic_long_cmpxchg_release(atomic_long_t *v, long old, long new)
          {
              return raw_atomic_cmpxchg_release(v, old, new);
          }
      
          static inline long raw_atomic_long_cmpxchg_relaxed(atomic_long_t *v, long old, long new)
          {
              return raw_atomic_cmpxchg_relaxed(v, old, new);
          }
      
          static inline bool raw_atomic_long_try_cmpxchg(atomic_long_t *v, long *old, long new)
          {
              return raw_atomic_try_cmpxchg(v, old, new);
          }
      
          static inline bool raw_atomic_long_try_cmpxchg_acquire(atomic_long_t *v, long *old, long new)
          {
              return raw_atomic_try_cmpxchg_acquire(v, old, new);
          }
      
          static inline bool raw_atomic_long_try_cmpxchg_release(atomic_long_t *v, long *old, long new)
          {
              return raw_atomic_try_cmpxchg_release(v, old, new);
          }
      
          static inline bool raw_atomic_long_try_cmpxchg_relaxed(atomic_long_t *v, long *old, long new)
          {
              return raw_atomic_try_cmpxchg_relaxed(v, old, new);
          }
      
          static inline bool raw_atomic_long_sub_and_test(long i, atomic_long_t *v)
          {
              return raw_atomic_sub_and_test(i, v);
          }
      
          static inline bool raw_atomic_long_dec_and_test(atomic_long_t *v)
          {
              return raw_atomic_dec_and_test(v);
          }
      
          static inline bool raw_atomic_long_inc_and_test(atomic_long_t *v)
          {
              return raw_atomic_inc_and_test(v);
          }
      
          static inline bool raw_atomic_long_add_negative(long i, atomic_long_t *v)
          {
              return raw_atomic_add_negative(i, v);
          }
      
          static inline long raw_atomic_long_fetch_add_unless(atomic_long_t *v, long a, long u)
          {
              return raw_atomic_fetch_add_unless(v, a, u);
          }
      
          static inline bool raw_atomic_long_add_unless(atomic_long_t *v, long a, long u)
          {
              return raw_atomic_add_unless(v, a, u);
          }
      
          static inline bool raw_atomic_long_inc_not_zero(atomic_long_t *v)
          {
              return raw_atomic_inc_not_zero(v);
          }
      
          static inline bool raw_atomic_long_inc_unless_negative(atomic_long_t *v)
          {
              return raw_atomic_inc_unless_negative(v);
          }
      
          static inline bool raw_atomic_long_dec_unless_positive(atomic_long_t *v)
          {
              return raw_atomic_dec_unless_positive(v);
          }
      
          static inline long raw_atomic_long_dec_if_positive(atomic_long_t *v)
          {
              return raw_atomic_dec_if_positive(v);
          }
      
          #endif /* CONFIG_64BIT */
      
          #endif /* _LINUX_ATOMIC_LONG_H */
          EOF
      - name: 🛠️ Fix SELinux headers and atomic operations
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Fix SELinux headers
          CLASSMAP="common/security/selinux/include/classmap.h"
          INIT_SID="common/security/selinux/include/initial_sid_to_string.h"
          GENHEADERS="common/scripts/selinux/genheaders/genheaders.c"
          
          # Remove extern from initialized variables
          sed -i 's/^extern const struct security_class_mapping secclass_map\[\]/const struct security_class_mapping secclass_map[]/' "$CLASSMAP"
          sed -i 's/^extern const char \*const initial_sid_to_string\[\]/const char *const initial_sid_to_string[]/' "$INIT_SID"
          
          # Fix genheaders.c
          sed -i '1i #include <stdlib.h>\n#include <string.h>' "$GENHEADERS"
          sed -i 's/^void usage(void)/static void usage(void)/' "$GENHEADERS"
          
          # Ensure asm-generic/atomic-long.h exists
          mkdir -p common/include/asm-generic
          cat << 'EOF' > common/include/asm-generic/atomic-long.h
          #ifndef _ASM_GENERIC_ATOMIC_LONG_H
          #define _ASM_GENERIC_ATOMIC_LONG_H
          
          #include <linux/atomic.h>
          
          #ifdef CONFIG_64BIT
          typedef atomic64_t atomic_long_t;
          #define ATOMIC_LONG_INIT(i) ATOMIC64_INIT(i)
          #else
          typedef atomic_t atomic_long_t;
          #define ATOMIC_LONG_INIT(i) ATOMIC_INIT(i)
          #endif
          
          #endif /* _ASM_GENERIC_ATOMIC_LONG_H */
          EOF
          
          # Add compiletime_assert_atomic_type if missing
          COMPILER_H="common/include/linux/compiler.h"
          if ! grep -q "compiletime_assert_atomic_type" "$COMPILER_H"; then
            cat << 'EOF' >> "$COMPILER_H"
          
          #define compiletime_assert_atomic_type(t) \
            compiletime_assert(__native_word(t), \
              "Need native word sized stores/loads for atomicity.")
          EOF
          fi
          
          # Fix atomic-long.h reference
          sed -i 's|<asm-generic/atomic-long.h>|<linux/atomic/atomic-long.h>|' common/include/linux/atomic/atomic-long.h
      - name: 🔧 Ensure atomic headers are complete
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Create compiler_types.h if missing
          COMPILER_TYPES="common/include/linux/compiler_types.h"
          if [ ! -f "$COMPILER_TYPES" ]; then
            mkdir -p $(dirname "$COMPILER_TYPES")
            cat << 'EOF' > "$COMPILER_TYPES"
          #ifndef _LINUX_COMPILER_TYPES_H
          #define _LINUX_COMPILER_TYPES_H
      
          #define __native_word(t) (sizeof(t) <= sizeof(long))
      
          #endif /* _LINUX_COMPILER_TYPES_H */
          EOF
          fi
      
          # Verify atomic headers
          mkdir -p common/include/linux/atomic
          [ -f "common/include/linux/atomic/atomic-long.h" ] || \
            cp $GITHUB_WORKSPACE/patches/atomic-long.h common/include/linux/atomic/
          [ -f "common/include/linux/atomic/atomic-raw64-compat.h" ] || \
            cp $GITHUB_WORKSPACE/patches/atomic-raw64-compat.h common/include/linux/atomic/
      - name: 🔍 Verify critical fixes
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Verify atomic-long.h exists
          if [ ! -f "common/include/asm-generic/atomic-long.h" ]; then
            echo "❌ Error: atomic-long.h still missing!"
            exit 1
          fi
          
          # Verify SELinux fixes
          if grep -q "^extern const struct security_class_mapping" common/security/selinux/include/classmap.h; then
            echo "❌ Error: SELinux classmap.h not fixed!"
            exit 1
          fi
          
          echo "✅ All critical fixes verified"
      - name: 🔧 Fix atomic operations and compiler definitions
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          # Create compiler_types.h with all necessary definitions
          COMPILER_TYPES="common/include/linux/compiler_types.h"
          mkdir -p $(dirname "$COMPILER_TYPES")
          cat << 'EOF' > "$COMPILER_TYPES"
          #ifndef _LINUX_COMPILER_TYPES_H
          #define _LINUX_COMPILER_TYPES_H
      
          #define __native_word(t) (sizeof(t) <= sizeof(long))
      
          /* Macro for compile-time assertions */
          #define compiletime_assert(condition, msg) \
              _Static_assert(condition, msg)
      
          #define compiletime_assert_atomic_type(t) \
              compiletime_assert(__native_word(t), \
                  "Need native word sized stores/loads for atomicity.")
      
          #endif /* _LINUX_COMPILER_TYPES_H */
          EOF
      
          # Create atomic-long.h if missing
          ATOMIC_LONG="common/include/asm-generic/atomic-long.h"
          mkdir -p $(dirname "$ATOMIC_LONG")
          cat << 'EOF' > "$ATOMIC_LONG"
          #ifndef _ASM_GENERIC_ATOMIC_LONG_H
          #define _ASM_GENERIC_ATOMIC_LONG_H
      
          #include <linux/types.h>
          #include <linux/compiler.h>
      
          #ifdef CONFIG_64BIT
          typedef atomic64_t atomic_long_t;
          #define ATOMIC_LONG_INIT(i) ATOMIC64_INIT(i)
          #else
          typedef atomic_t atomic_long_t;
          #define ATOMIC_LONG_INIT(i) ATOMIC_INIT(i)
          #endif
      
          #endif /* _ASM_GENERIC_ATOMIC_LONG_H */
          EOF
      
          # Create atomic-raw64-compat.h with proper atomic64 fallbacks
          ATOMIC_RAW64="common/include/linux/atomic/atomic-raw64-compat.h"
          mkdir -p $(dirname "$ATOMIC_RAW64")
          cat << 'EOF' > "$ATOMIC_RAW64"
          #ifndef _LINUX_ATOMIC_RAW64_COMPAT_H
          #define _LINUX_ATOMIC_RAW64_COMPAT_H
      
          #include <linux/types.h>
          #include <linux/compiler.h>
          #include <asm-generic/atomic-long.h>
      
          /* Fallback implementations for raw_atomic64_* functions */
          static inline s64 raw_atomic64_read(const atomic64_t *v)
          {
              return v->counter;
          }
      
          static inline s64 raw_atomic64_read_acquire(const atomic64_t *v)
          {
              return smp_load_acquire(&v->counter);
          }
      
          static inline void raw_atomic64_set(atomic64_t *v, s64 i)
          {
              v->counter = i;
          }
      
          static inline void raw_atomic64_set_release(atomic64_t *v, s64 i)
          {
              smp_store_release(&v->counter, i);
          }
      
          /* Add more atomic operations as needed... */
      
          #endif /* _LINUX_ATOMIC_RAW64_COMPAT_H */
          EOF
      
          # Fix SELinux headers
          CLASSMAP="common/security/selinux/include/classmap.h"
          INIT_SID="common/security/selinux/include/initial_sid_to_string.h"
          GENHEADERS="common/scripts/selinux/genheaders/genheaders.c"
          
          # Remove extern from initialized variables
          sed -i 's/^extern const struct security_class_mapping secclass_map\[\]/const struct security_class_mapping secclass_map[]/' "$CLASSMAP"
          sed -i 's/^extern const char \*const initial_sid_to_string\[\]/const char *const initial_sid_to_string[]/' "$INIT_SID"
          
          # Fix genheaders.c
          sed -i '1i #include <stdlib.h>\n#include <string.h>' "$GENHEADERS"
          sed -i 's/^void usage(void)/static void usage(void)/' "$GENHEADERS"
      
          # Ensure proper includes in atomic.h
          ATOMIC_H="common/include/linux/atomic.h"
          if ! grep -q "atomic-raw64-compat.h" "$ATOMIC_H"; then
            sed -i '1i #include <linux/atomic/atomic-raw64-compat.h>' "$ATOMIC_H"
          fi
      
          echo "✅ Atomic operations and compiler definitions fixed"
      - name: Fix Kernel Headers and Atomics
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          set -euxo pipefail

          # 1. Fix fortify-string.h function prototype
          FORTIFY_FILE="common/include/linux/fortify-string.h"
          sed -i 's/void abort();/void abort(void);/' "$FORTIFY_FILE"

          # 2. Define ALWAYS_INLINE (our custom macro) and other workarounds.
          COMPILER_FILE="common/include/linux/compiler_attributes.h"
          if [ ! -f "$COMPILER_FILE" ]; then
            COMPILER_FILE="common/include/linux/compiler.h"
          fi

          cat << 'EOF' >> "$COMPILER_FILE"
          /* User-space compilation workarounds */
          // Define our custom ALWAYS_INLINE macro.  This is what we
          // will *actually* use throughout our code.  We do NOT
          // attempt to redefine __always_inline.

          #ifndef __user
          #define __user
          #endif
          #ifndef __kernel
          #define __kernel
          #endif
          #ifndef __force
          #define __force
          #endif
          #ifndef __must_check
          #define __must_check
          #endif
          #ifndef __cold
          #define __cold
          #endif
          #ifndef __noreturn
          #define __noreturn
          #endif
          #ifndef __section
          #define __section(x)
          #endif
          #ifndef __latent_entropy
          #define __latent_entropy
          #endif
          #ifndef __noinitretpoline
          #define __noinitretpoline
          #endif
          #ifndef __no_sanitize_or_inline
          #define __no_sanitize_or_inline inline
          #endif
          #ifndef __no_kasan_or_inline
          #define __no_kasan_or_inline inline
          #endif
          #ifndef __realloc_size
          #define __realloc_size(x, ...)
          #endif
          #ifndef __unqual_scalar_typeof
          #define __unqual_scalar_typeof(x) typeof(x)
          #endif
          #ifndef __counted_by
          #define __counted_by(x)
          #endif
          #ifndef __member_size
          #define __member_size(p) 0
          #endif
          #ifndef __struct_size
          #define __struct_size(p) 0
          #endif
          #ifndef __fortify_panic
          #define __fortify_panic(reason, avail, size) abort()
          #endif
          #ifndef fortify_panic
          #define fortify_panic(func, write, avail, size, p) abort()
          #endif
          EOF

          # Fix init.h empty macro
          INIT_FILE="common/include/linux/init.h"
          [ -f "$INIT_FILE" ] && sed -i '/^#define $/d' "$INIT_FILE"

          # Fix ftrace likely data declaration
          FTRACE_FILE="common/include/linux/compiler.h"
          [ -f "$FTRACE_FILE" ] && sed -i 's/struct ftrace_likely_data \*f/void \*f/' "$FTRACE_FILE"

          # 3. Create atomic-long.h (using ALWAYS_INLINE)
          mkdir -p common/include/linux/atomic
          cat << EOF > common/include/linux/atomic/atomic-long.h
          #ifndef _LINUX_ATOMIC_LONG_H
          #define _LINUX_ATOMIC_LONG_H

          #include <linux/compiler.h>
          #include <linux/types.h>
          #include <asm-generic/atomic-long.h>
          #include <linux/atomic/atomic-raw64-compat.h>

          #ifdef CONFIG_64BIT
          typedef atomic64_t atomic_long_t;
          #define ATOMIC_LONG_INIT(i)        ATOMIC64_INIT(i)
          #else
          typedef atomic_t atomic_long_t;
          #define ATOMIC_LONG_INIT(i)        ATOMIC_INIT(i)
          #endif

            // Use ALWAYS_INLINE (our custom macro)
            static inline long raw_atomic_long_read(const atomic_long_t *v)
            {
                return raw_atomic64_read(v);
            }

            static inline void raw_atomic_long_set(atomic_long_t *v, long i)
            {
                raw_atomic64_set(v,i);
            }

            static inline void raw_atomic_long_add(long i, atomic_long_t *v)
            {
                raw_atomic64_add(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_add_return(long i, atomic_long_t *v)
            {
                return raw_atomic64_add_return(i,v);
            }
             static ALWAYS_INLINE long raw_atomic_long_add_return_acquire(long i, atomic_long_t *v)
            {
                return raw_atomic64_add_return_acquire(i,v);
            }
             static ALWAYS_INLINE long raw_atomic_long_add_return_release(long i, atomic_long_t *v)
            {
                return raw_atomic64_add_return_release(i,v);
            }
             static ALWAYS_INLINE long raw_atomic_long_add_return_relaxed(long i, atomic_long_t *v)
            {
                return raw_atomic64_add_return_relaxed(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_fetch_add(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_add(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_fetch_add_acquire(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_add_acquire(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_fetch_add_release(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_add_release(i,v);
            }
             static ALWAYS_INLINE long raw_atomic_long_fetch_add_relaxed(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_add_relaxed(i,v);
            }
            static inline void raw_atomic_long_sub(long i, atomic_long_t *v)
            {
                raw_atomic64_sub(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_sub_return(long i, atomic_long_t *v)
            {
               return  raw_atomic64_sub_return(i,v);
            }
             static ALWAYS_INLINE long raw_atomic_long_sub_return_acquire(long i, atomic_long_t *v)
            {
               return  raw_atomic64_sub_return_acquire(i,v);
            }
             static ALWAYS_INLINE long raw_atomic_long_sub_return_release(long i, atomic_long_t *v)
            {
               return raw_atomic64_sub_return_release(i,v);
            }
             static ALWAYS_INLINE long raw_atomic_long_sub_return_relaxed(long i, atomic_long_t *v)
            {
                return raw_atomic64_sub_return_relaxed(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_fetch_sub(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_sub(i,v);
            }
             static ALWAYS_INLINE long raw_atomic_long_fetch_sub_acquire(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_sub_acquire(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_fetch_sub_release(long i, atomic_long_t *v)
            {
                return raw_atomic64_fetch_sub_release(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_fetch_sub_relaxed(long i, atomic_long_t *v)
            {
               return raw_atomic64_fetch_sub_relaxed(i,v);
            }
            static inline void raw_atomic_long_inc(atomic_long_t *v)
            {
                raw_atomic64_inc(v);
            }
            static ALWAYS_INLINE long raw_atomic_long_inc_return(atomic_long_t *v){
                return raw_atomic64_inc_return(v);
            }
            static ALWAYS_INLINE long raw_atomic_long_fetch_inc(atomic_long_t *v){
               return raw_atomic64_fetch_inc(v);
            }
            static inline void raw_atomic_long_dec(atomic_long_t *v)
            {
              raw_atomic64_dec(v);
            }
            static ALWAYS_INLINE long raw_atomic_long_dec_return(atomic_long_t *v){
                return raw_atomic64_dec_return(v);
            }
            static ALWAYS_INLINE long raw_atomic_long_fetch_dec(atomic_long_t *v){
                return raw_atomic64_fetch_dec(v);
            }
            static inline void raw_atomic_long_and(long i, atomic_long_t *v){
                raw_atomic64_and(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_fetch_and(long i, atomic_long_t *v){
               return raw_atomic64_fetch_and(i,v);
            }
            static inline void raw_atomic_long_andnot(long i, atomic_long_t *v){
                raw_atomic64_andnot(i,v);
            }
             static ALWAYS_INLINE long raw_atomic_long_fetch_andnot(long i, atomic_long_t *v){
               return  raw_atomic64_fetch_andnot(i,v);
            }
            static inline void raw_atomic_long_or(long i, atomic_long_t *v){
                raw_atomic64_or(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_fetch_or(long i, atomic_long_t *v){
                return raw_atomic64_fetch_or(i,v);
            }
            static inline void raw_atomic_long_xor(long i, atomic_long_t *v){
                raw_atomic64_xor(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_fetch_xor(long i, atomic_long_t *v){
               return raw_atomic64_fetch_xor(i,v);
            }
            static ALWAYS_INLINE long raw_atomic_long_xchg(atomic_long_t *v, long new){
             return raw_atomic64_xchg(v,new);
            }
            static ALWAYS_INLINE long raw_atomic_long_cmpxchg(atomic_long_t *v, long old, long new){
             return raw_atomic64_cmpxchg(v,old,new);
            }
            static ALWAYS_INLINE bool raw_atomic_long_try_cmpxchg(atomic_long_t *v, long *old, long new){
            return  raw_atomic64_try_cmpxchg(v,old,new);
            }
            static inline bool raw_atomic_long_sub_and_test(long i, atomic_long_t *v){
                return raw_atomic64_sub_and_test(i,v);
            }
             static inline bool raw_atomic_long_dec_and_test(atomic_long_t *v){
                return raw_atomic64_dec_and_test(v);
            }
            static inline bool raw_atomic_long_inc_and_test(atomic_long_t *v){
                return raw_atomic64_inc_and_test(v);
            }
             static inline bool raw_atomic_long_add_negative(long i, atomic_long_t *v){
                return raw_atomic64_add_negative(i,v);
            }
            static inline long raw_atomic_long_fetch_add_unless(atomic_long_t *v, long a, long u){
                return raw_atomic64_fetch_add_unless(v,a,u);
            }
            static inline bool raw_atomic_long_add_unless(atomic_long_t *v, long a, long u){
                return raw_atomic64_add_unless(v,a,u);
            }
             static inline bool raw_atomic_long_inc_not_zero(atomic_long_t *v){
                return raw_atomic64_inc_not_zero(v);
            }
            static inline bool raw_atomic_long_inc_unless_negative(atomic_long_t *v){
                return raw_atomic64_inc_unless_negative(v);
            }
            static inline bool raw_atomic_long_dec_unless_positive(atomic_long_t *v){
                return raw_atomic64_dec_unless_positive(v);
            }
            static inline long raw_atomic_long_dec_if_positive(atomic_long_t *v){
             return raw_atomic64_dec_if_positive(v);
            }
          #endif
          EOF

          echo "✅ Fixed kernel header compilation issues and created atomic-long.h"

      
      - name: 🛠️ Patch __always_inline redefinition
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        run: |
          echo "🔍 Patching __always_inline macro redefinition..."
      
          COMP_ATTR="common/include/linux/compiler_attributes.h"
          STDDEF="common/include/uapi/linux/stddef.h"

          echo "Before patching:"
          grep -Hn '^#define __always_inline' "$COMP_ATTR" "$STDDEF" || true
      
          if [ -f "$COMP_ATTR" ]; then
            echo "🛡️ Patching $COMP_ATTR"
            sed -i '/^#define __always_inline[[:space:]]\+inline __attribute__((__always_inline__))$/{
              i #ifndef __always_inline
              a #endif
            }' "$COMP_ATTR"
          else
            echo "⚠️ $COMP_ATTR not found!"
          fi
      
          if [ -f "$STDDEF" ]; then
            echo "🛡️ Patching $STDDEF"
            sed -i '/^#define __always_inline[[:space:]]\+inline$/{
              i #ifndef __always_inline
              a #endif
            }' "$STDDEF"
          else
            echo "⚠️ $STDDEF not found!"
          fi

          echo "✅ __always_inline macro patched (if needed)"
          grep -Hn '__always_inline' "$COMP_ATTR" "$STDDEF" || true

            # Step to add genrule to BUILD.bazel for patching __always_inline conflicts
      - name: Add genrule to BUILD.bazel to patch __always_inline conflicts
        run: |
          BUILD_FILE="BUILD.bazel"
          
          # Define the genrule to run patching
          GENRULE='genrule(
          name = "patch_headers",
          outs = ["patched_compiler_attributes.h", "patched_stddef.h"],
          cmd = "sed -i '\''/define __always_inline/ i #ifndef __always_inline'\'' common/include/linux/compiler_attributes.h && sed -i '\''/define __always_inline/ i #ifndef __always_inline'\'' common/include/uapi/linux/stddef.h",
          )"'
          
          # Check if the genrule already exists, if not, append it
          if ! grep -q "patch_headers" "$BUILD_FILE"; then
            echo "🔧 Adding genrule to BUILD.bazel"
            # Add the genrule to the BUILD.bazel file
            echo "$GENRULE" >> "$BUILD_FILE"
          else
            echo "⚠️ Genrule 'patch_headers' already exists in BUILD.bazel"
          fi
          
          # Verify the genrule was added
          tail -n 20 "$BUILD_FILE"  # Show the last 20 lines to verify the genrule is added
      - name: Patch kernel for missing raw_atomic64_* functions and ALWAYS_INLINE
        run: |
          # Create the patch file for missing raw_atomic64_* functions
          echo '### Creating the patch for raw_atomic64 functions ###'
          cat << 'EOF' > patches/raw_atomic64_patch.patch
          #include <linux/atomic.h>  # Ensure atomic operations are available
      
          #ifndef ALWAYS_INLINE
          #define ALWAYS_INLINE inline __attribute__((always_inline))  # Define ALWAYS_INLINE if not already defined
          #endif
      
          # Define missing raw_atomic64_* functions if not already available
          #define raw_atomic64_add(i, v) atomic_add((i), (v))
          #define raw_atomic64_add_return(i, v) atomic_add_return((i), (v))
          #define raw_atomic64_add_return_acquire(i, v) atomic_add_return_acquire((i), (v))
          #define raw_atomic64_add_return_release(i, v) atomic_add_return_release((i), (v))
          #define raw_atomic64_add_return_relaxed(i, v) atomic_add_return_relaxed((i), (v))
      
          # Define the functions used in the file as inline functions
          static ALWAYS_INLINE long raw_atomic_long_add_return(long i, atomic_long_t *v)
          {
              return raw_atomic64_add_return(i, v);
          }
      
          static ALWAYS_INLINE long raw_atomic_long_add_return_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic64_add_return_acquire(i, v);
          }
      
          static ALWAYS_INLINE long raw_atomic_long_add_return_release(long i, atomic_long_t *v)
          {
              return raw_atomic64_add_return_release(i, v);
          }
      
          static ALWAYS_INLINE long raw_atomic_long_add_return_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic64_add_return_relaxed(i, v);
          }
      
          # Repeat for fetch_add, if needed:
          static ALWAYS_INLINE long raw_atomic_long_fetch_add(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_add(i, v);
          }
      
          static ALWAYS_INLINE long raw_atomic_long_fetch_add_acquire(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_add_acquire(i, v);
          }
      
          static ALWAYS_INLINE long raw_atomic_long_fetch_add_release(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_add_release(i, v);
          }
      
          static ALWAYS_INLINE long raw_atomic_long_fetch_add_relaxed(long i, atomic_long_t *v)
          {
              return raw_atomic64_fetch_add_relaxed(i, v);
          }
      
          EOF
      
          # Check if the patch file is created successfully
          cat patches/raw_atomic64_patch.patch
          echo '### Applying the patch ###'
      
          # Apply the patch
          git apply --allow-empty patches/raw_atomic64_patch.patch
      
          # Clean up by removing the patch file
          rm patches/raw_atomic64_patch.patch
      - name: Inject raw_atomic64 fallback and ALWAYS_INLINE definition
        run: |
          # Ensure target directory exists
          mkdir -p kernel_platform/common/include/linux/atomic
      
          # Ensure atomic-long.h exists
          touch kernel_platform/common/include/linux/atomic/atomic-long.h
      
          # Append raw_atomic64 fallback definitions
          cat patches/raw_atomic64_fallback.h >> kernel_platform/common/include/linux/atomic/atomic-long.h
      
          # Add ALWAYS_INLINE definition if not present
          {
            echo '#ifndef ALWAYS_INLINE'
            echo '#define ALWAYS_INLINE inline __attribute__((always_inline))'
            echo '#endif'
          } >> kernel_platform/common/include/linux/compiler_types.h
      - name: Patch atomic64 fallbacks
        run: |
          patch -d kernel_platform/common/include/linux/atomic -p0 < patches/atomic64_fallback.patch
      - name: Inject atomic64 fallback
        run: |
          mkdir -p kernel_platform/common/include/linux/atomic
          cp patches/include/linux/atomic/atomic64_fallback.h kernel_platform/common/include/linux/atomic/
      
          # Inject into global build via CPPFLAGS
          echo '#include "linux/atomic/atomic64_fallback.h"' >> kernel_platform/common/include/linux/kernel.h


      - name: Build Kernel
        working-directory: ${{ env.BUILD_DIR }}/${{ env.KERNEL_DIR }}/kernel_platform
        env:
          KCONFIG_CONFIG: common/out/.config
        run: |
          set -euxo pipefail
          ls -l common/include/net/netns/mib.h
          echo "🔍 Verifying copied header:"
          find common/include/net/netns/ -name "mib.h"
          mkdir -p out
          start_time=$(date +%s)
          # --- CRITICAL: Disable ccache temporarily ---
          # export PATH="/usr/lib/ccache:$PATH"  # Comment this out
          export CCACHE_DISABLE=1
          ./tools/bazel clean --expunge
      
          # Corrected --cflags and removed duplicate flags
          ./build_with_bazel.py \
            -t pineapple gki \
            --jobs="$(nproc --all)" \
            --verbose_failures \
            --sandbox_debug \
            --subcommands \
            --config=stamp \
            --user_kmi_symbol_lists=//msm-kernel:android/abi_gki_aarch64_qcom \
            --ignore_missing_projects \
            -o "$(pwd)/out" \
            --copt=-Icommon/include \
            --copt=-Icommon/arch/arm64/include \
            --//msm-kernel:skip_abi=true \
            --//msm-kernel:skip_abl=true \
            //msm-kernel:pineapple_gki_dist \
            //msm-kernel:pineapple_gki_dtc_dist
      
          end_time=$(date +%s)
          build_time=$((end_time - start_time))
          echo "Kernel build time: $build_time seconds"
      - name: Auto-retry Bazel build with header restoration
        run: |
          set -e
          UPSTREAM_DIR=upstream-linux/include
          DEST_ROOT=common/include
          MAX_RETRIES=5
          LOG_FILE=build.log
      
          restore_headers() {
            echo "📄 Scanning for missing headers..."
            grep -oP "fatal error: '\K[^']+(?=')" "$LOG_FILE" | sort -u > missing_headers.txt
      
            if [[ ! -s missing_headers.txt ]]; then
              echo "✅ No missing headers found."
              return 1
            fi
      
            echo "📂 Restoring headers from $UPSTREAM_DIR..."
            while read -r HEADER; do
              SRC="$UPSTREAM_DIR/$HEADER"
              DEST="$DEST_ROOT/$HEADER"
              DEST_DIR=$(dirname "$DEST")
      
              echo "→ $HEADER"
              if [ -f "$SRC" ]; then
                mkdir -p "$DEST_DIR"
                cp "$SRC" "$DEST"
                echo "✓ Restored $HEADER"
              else
                echo "⚠️ Header not found: $SRC"
              fi
            done < missing_headers.txt
            return 0
          }
      
          run_build() {
            echo "⚙️ Running Bazel build..."
            ./build_with_bazel.py \
              -t pineapple gki \
              --jobs="$(nproc --all)" --verbose_failures --config=stamp \
              --user_kmi_symbol_lists=//msm-kernel:android/abi_gki_aarch64_qcom \
              --ignore_missing_projects -o "$(pwd)/out" &> "$LOG_FILE"
          }
      
          echo "🚀 Starting auto-build with header patching..."
          for i in $(seq 1 $MAX_RETRIES); do
            echo "🔁 Attempt $i/$MAX_RETRIES"
            if run_build; then
              echo "🎉 Build succeeded on attempt $i!"
              exit 0
            fi
      
            echo "❌ Build failed. Checking for missing headers..."
            if ! restore_headers; then
              echo "🧼 No headers to restore. Exiting loop."
              break
            fi
            echo "♻️ Retrying build..."
          done
      
          echo "❗ Build failed after $MAX_RETRIES attempts."
          exit 1

      - name: Create ZIP Package
        working-directory: ${{ env.BUILD_DIR }}
        run: |
          set -euxo pipefail
          mkdir -p AnyKernel3
          touch AnyKernel3/Image
          cp kernel_platform/oneplus12_v/kernel_platform/out/dist/Image AnyKernel3/Image || { echo "Error copying Image file"; exit 1; }
          cd AnyKernel3
          ZIP_NAME="Cabage-OP12-SUSFS-$(date +'%Y-%m-%d-%H-%M-%S').zip"
          echo "Creating zip file $ZIP_NAME..."
          zip -r "../$ZIP_NAME" ./*
          ls -lh "../$ZIP_NAME"
          echo "zip_name=$ZIP_NAME" >> $GITHUB_ENV
      - name: Set current timestamp
        id: timestamp
        run: echo "CURRENT_TIMESTAMP=$(date -u +'%Y.%m.%d-%H%M%S')" >> $GITHUB_ENV

      - name: Create Release
        id: create_release
        uses: softprops/action-gh-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          files: ${{ env.BUILD_DIR }}/${{ env.zip_name }}
          tag_name: release-${{ env.CURRENT_TIMESTAMP }} # Simple, safe tag
          name: Release ${{ env.ROOT_DIR_PREFIX }} ${{ env.zip_name }}
          body: |
             Release for ${{ env.ROOT_DIR_PREFIX }} based on branch ${{ env.BRANCH }}
             KSU Version: ${{ env.KSUVER }}  # Still *include* KSUVER in the body
             Timestamp: ${{ env.CURRENT_TIMESTAMP }}
      - name: Upload Build Logs
        uses: actions/upload-artifact@v4
        if: ${{ always() && failure() }}
        with:
          name: build-logs
          path: |
            ${{ env.BUILD_DIR }}/kernel_platform/oneplus12_v/kernel_platform/out/*.log
            ${{ env.BUILD_DIR }}/kernel_platform/oneplus12_v/kernel_platform/**/*.rej
          retention-days: 5
          if-no-files-found: error
